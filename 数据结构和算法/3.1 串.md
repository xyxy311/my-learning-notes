# 定义和概念

**串**即**字符串**，由0个或多个==字符==组成的有限序列
**子串**，由串中任意个连续字符组成
**空格串**，不等于 ***空串*** (∅)，而是由数个空格组成

# 存储结构

## 顺序存储结构

串多采用此法存储

```cpp
// 定长顺序存储
typedef struct {
    char ch[MAXLEN + 1];  // 书中的串从索引1开始
    int length;
} SString;

// 堆式顺序存储
typedef struct {
    char* ch;
    int length;
} HString;
```

## 链式存储结构

每个节点可以存一个字符，也可以多个，后一情况下，需要用 非字符串内容 填满节点剩余空间
同时设置 头指针 和 尾指针，并给出 长度，如此定义的串，称为**块链结构**

```cpp
// 链式存储
typedef struct Chunk{
    char ch[CHUNKSIZE];
    struct Chunk *next;
} Chunk;

typedef struct {
    Chunk *head, *tail;
    int length;
} LString;
```

# 模式匹配算法

也就是 子串的定位算法
设 S 为主串，T 为子串，若 T 在 S 中，则返回首字符在 S 中的位置

## BF 算法

依次匹配 T 和 S，若匹配失败，回溯 T，S 的指针重新指向首元素

```cpp
// BF算法，指定从某个位置开始查询，注意数组从索引1处开始存储
// 如果没找到 index=0
int Index_BF(SString S, SString T, int pos = 1) {
    int i = pos, j = 1;
    while (i <= S.length && j <= T.length) {
        if (S.ch[i] == T.ch[j]) {
            i++;
            j++;
        }
        else {
            i = i - j + 2;  // 注意要回溯到前一个地方
            j = 1;
        }
    }
    if (j > T.length)
        return i - T.length;  // 数字运算定位要注意
    else
        return 0;
}
```
![[Pasted image 20251223174229.png]]
![[Pasted image 20251223174245.png]]
## KMP 算法

i 始终增大，不回溯，每次适配都通过 `next[j]` 比较 i 与 新的 j 指向的字符
![[Pasted image 20251224062322.png]]
![[Pasted image 20251224065222.png]]
可改进next算法，即多算一步，若适配字符与`next[j]`指向的字符相等，则复用`nextval[next[j]]`的值，否则不变

如：

| j            | 1   | 2   | 3   | 4   | 5   |
| ------------ | --- | --- | --- | --- | --- |
| `T[j]`       | a   | a   | a   | a   | b   |
| `next[j]`    | 0   | 1   | 2   | 3   | 4   |
| `nextval[j]` | 0   | 0   | 0   | 0   | 4   |

![[Pasted image 20251224062143.png]]

```cpp
// 下标从1开始
// next[]
void getnext(SString S, int next[]) {
	next[1] = 0;
	int i = 1, j = 0;
	while (i < S.length) {  // 注意这里不应该为<=
		if (j == 0 || S.ch[i] == S.ch[j])
			next[++i] = ++j;
		else
			j = next[j];  // 缩小匹配前缀
	}
}

// KMP算法，pos标定起始点
int Index_KMP(SString S, SString T, int pos = 1) {
    int i = pos, j = 1;
    while (i <= S.length && j <= T.length) {
        if (j == 0 || S.ch[i] == T.ch[j]) {
            i++;
            j++;
        }
        else {
            j = next[j];
        }
    }
    if (j > T.length) {
        return i - j + 1;
    }
    else {
        return 0;
    }
}
```