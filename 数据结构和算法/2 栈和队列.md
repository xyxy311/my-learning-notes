也是线性表
**栈**：
	后进先出
**队列**：
	先进先出

# 顺序栈的表示和实现

![[Pasted image 20251216170811.png]]

```cpp
typedef struct {
    ElemType* base;
    ElemType* top;
    int stacksize;
}SqStack;

// 初始化
Status initStack(SqStack &S) {
    S.top = S.base = new ElemType[100];  // 分配数组空间
    if (!S.base) {
        return OVERFLOW;
    }
    S.stacksize = MAXSIZE;
    return OK;
}

// 入栈
Status push(SqStack &S, ElemType e) {
    if (S.top - S.base == S.stacksize) {
        return ERROR;
    }
    *(S.top++) = e;  // 注意先赋值后加，top指向的是空余处
    return OK;
}

// 出栈，把出栈对象赋值到 e 上
Status pop(SqStack &S, ElemType &e) {
    if (S.top == S.base) {
        return ERROR;
    }
    e = *(--S.top);  // 这里括号可以省略
    return OK;
}

// 取出栈顶元素，作为返回值
ElemType getTop(SqStack &S) {
    if (S.top != S.base) {
        return *(S.top-1);
    }
}
```

# 链栈的表示和实现

![[Pasted image 20251216174554.png]]
```cpp
typedef struct StackNode {  // 注意命名，先是节点，后是栈的指针
    ElemType data;
    struct StackNode* next; // 别忘了 struct
} StackNode, *LinkStack;

// 以下操作直接对 L 进行，L 始终指向栈顶
// 初始化
Status initStack(LinkStack &L) {
    L = nullptr;  // 直接置空，不需要设置头节点
    return OK;
}

// 入栈
Status push(LinkStack &L, ElemType e) {
    StackNode* p = new StackNode;
    p->data = e;
    p->next = L;  // 注意 next 是从上到下
    L = p;
    return OK;
}

// 出栈
Status pop(LinkStack &L, ElemType &e) {
    StackNode* p = L;
    if (!p) {
        return ERROR;
    }
    e = p->data;
    L = p->next;
    delete p;  // 删除栈顶节点
    return OK;
}

// 取出栈顶值
ElemType getTop(LinkStack &L) {
    if (L) {
        return L->data;
    }
}
```

# 栈与递归

## 使用递归算法解决问题
### 定义是递归的
**分治法**
![[Pasted image 20251217160321.png]]
![[Pasted image 20251217160729.png]]

### 数据结构是递归的

链表的节点`LNode`定义中，包括了`LNode`类型指针，用到了自身

遍历算法：
```cpp
void traverse(LinkList p) {
	if (p) {
		cout >> p >> endl;
		traverse(p->next);
	}
}
```

### 问题的解法是递归的

![[Pasted image 20251217161733.png]]
思路：
	目的：把 A 上的 n 个盘子移动到 C 上， 以 B 为辅助
	设 A 上的盘子数量为 n，若 n = 1 则移动次数 m+1 ，循环结束
	若 n > 1 
		则以 C 为辅助塔，把 A 上 (n-1) 个盘子移动到 B 
		A 上最后一个盘子移动到 C
		以 A 为辅助塔，把 B 上 (n-1) 个盘子移动到 C

```cpp
int m = 0;
// 把 A 上 n 个盘子移动到 C 上，B 为辅助塔
void Hanoi(char A, int n, char C, char B) {
	if (n == 1) {
		m++;
		return;
	}
	else {
		Hanoi(A, n-1, B, C);
		m++;  // 把 A 上的最后剩下的盘子移动到 C
		Hanoi(B, n-1, C, A);
	}
}
```

也可以省略A、B、C，进一步简化
```cpp
int HanoiCount(int n) {
	if (n == 1) return 1;
	return 2 * HanoiCount(n - 1) + 1;
} // 或直接 return (1 << n) - 1;
```

## 递归过程和递归工作栈

![[Pasted image 20251217165926.png]]
![[Pasted image 20251217170155.png]]
## 递归算法效率分析

**时间复杂度**
以 `Fact(int n)` 为例：
![[Pasted image 20251217170525.png]]
![[Pasted image 20251217171829.png]]

**空间复杂度**
以`Hanoi`为例：
每个递归调用都会压入一个栈帧
```cpp
Hanoi(A, n-1, B, C);   // 第一次递归
// 中间一步
Hanoi(B, n-1, C, A);   // 第二次递归
```
两个递归不是同时调用，所以最大递归深度是从 n 到 1，即有 n 层
每层栈帧有 7 个字节，为常数空间 *O(1)*
空间复杂度 为 *O(n)*

## 递归转化为非递归

![[Pasted image 20251217172733.png]]

# 循环（顺序）队列的表示和实现

循环是为了解决假溢出的问题
有两种方法解决区分“满”和“空”的问题：
- 最多储存 `MAXSIZE-1` 个元素
- 使用标志

![[Pasted image 20251218110117.png]]

**注意`front`和`rear`的指向**


```cpp
typedef struct {
    ElemType* base;  // 储存空间基地址
    int front; // 头指针
    int rear;  // 尾指针
} Quene;

//初始化
Status initQuene(Quene& q) {
    if (q.base = new ElemType[MAXSIZE]) {
        q.front = q.rear = 0;
        return OK;
    }
    return ERROR;
}

// 求队列的长度
int sizeQuene(Quene q) {
    return (q.rear - q.front + MAXSIZE) % MAXSIZE;
}

// 入队
Status enQueue(Quene& q, ElemType e) {
    if ((q.rear+1) % MAXSIZE == q.front) // 判断是否满了
        return ERROR;
    q.base[q.rear] = e;                  // 注意q.rear指向的是末尾元素的后一项
    q.rear = (q.rear+1) % MAXSIZE;
    return OK;
}

// 出队
Status deQuene(Quene& q, ElemType& e) {
    if (q.front == q.rear) {
        return ERROR;
    }
    e = q.base[q.front];
    q.front = (q.front+1) % MAXSIZE;
    return OK;
}
```

# 链队的表示和实现

需要头节点、需要两个指针

```cpp
typedef struct QNode {
    ElemType data;
    struct QNode* next;
} QNode, *QNptr;

typedef struct {
    QNptr front;
    QNptr rear;
}LQueue;

// 初始化
Status initLQueue(LQueue& q) {
    q.front = q.rear = new QNode; // 头节点
    q.front->next = nullptr;      // 注意置空
    return OK;
}

// 入队
Status enLQueue(LQueue& q, ElemType e) {
    q.rear->next = new QNode;
    q.rear = q.rear->next;
    q.rear->data = e;
    q.rear->next = nullptr;
    return OK;
}

// 出队
Status deLQueue(LQueue& q, ElemType& e) {
    QNode* p = q.front->next;  // 指向首元素
    if (!p) {
        return ERROR;
    }
    e = p->data;
    q.front->next = p->next;
    if (p == q.rear)         // 这里不要忘，判断是否删除了最后一个元素
        q.rear = q.front;
    delete p;
    return OK;
}
```

# 应用

## 十进制转八进制

```cpp
initStack(S)
while (n) {  // n 是一个十进制数
	S.push(n % 8);
	n = n / 8;
}
while (S) {
	cout << S.pop();
}
```

## 括号匹配检验

```cpp
bool check() {
	initStack(S)   // 储存括号
	char ch;
	while (1) {
		cin >> ch;
		if (ch == ';')  // 判断是否读完了一条表达式
			break;
		switch (ch) {
			case '(':
			case '[':
				S.push(ch);
				break;
			case ')':
				if (S.isempty() || S.pop() != '(') // 注意要先检验是否为空，下面同理
					return false;
				break;
			case ']':
				if (S.isempty() || S.pop() != '[')
					return false;
				break;
		}
	}
	return S.isempty();  // 如果括号stack为空，则结果正确
}
```
## 表达式求值

```cpp
char compare(char, char) // 比较两个运算符优先级大小
bool isOperator(char) // 判断是否为运算符
int operate(char, char, char)  // 运算

int getValue() {  // 表达式求值，假设表达式输入正确，只涉及二元运算
	initStack(OPND); // 存放操作数
	initStack(OPTR); // 存放运算符
	cin >> ch;
	while (!OPTR.isempty()) {
		if (isOperator(ch)) {
			switch (compare(getTop(OPTR), ch)) {
				case '<' :
					OPTR.push(ch);
					cin >> ch;
					break;
				case '>' :
					op = OPTR.pop();
					a = OPND.pop();
					b = OPND.pop();
					OPND.push(operate(b, op, a));
					break;
				case '=' :
					OPTR.pop();
					cin >> ch;
					break;
			}
		}
		else {
			OPND.push(ch);
			cin >> ch;
		}
	}
	return getTop(OPND);
}
```

## 舞伴配对

```cpp
while (!Man.isempty() && !Woman.isempty) {
	Dequeue(Man, p);
	cout << p.name << " & ";
	Dequeue(Woman, p);
	cout << p.name << endl;
}
if (Man.isempty()) {
	cout << getTop(Woman).name << "will be the first to get a partner.";
}
else {
	cout << getTop(Man).name << "will be the first to get a partner.";
}
```