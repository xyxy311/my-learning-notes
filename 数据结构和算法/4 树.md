![[Pasted image 20251230160749.png]]
![[Pasted image 20251230160810.png]]

# 术语

结点
根节点
结点的度：结点拥有的子树数
树的度：树内所有结点的度的最大值
叶子（终端节点）： 度为0
双亲 孩子 祖先 子孙 兄弟 堂兄弟
![[Pasted image 20251230161857.png]]
树的深度：最大层次数

有序树/无序树
森林：m>=0棵不相交的树的集合
	一棵树可以看作一个特殊的森林
	给森林中的各个子树加上一个双亲节点，森林就变成了树

# 二叉树

**二叉树**：最简单、规律性强，可以由普通树转化而来
	左子树 / 右子树，次序不能颠倒，即便只有一个子树
	![[Pasted image 20251230162915.png]]
	![[Pasted image 20251230163013.png]]
	二叉树不是树的特殊情况

## 二叉树的性质

![[Pasted image 20251231172654.png]]
![[Pasted image 20251231172727.png]]
完全二叉树的特点：
- 叶子只在最后两层出现
- 若某一结点右分支子孙最大层次为 *l*，则左分支子孙最大层次为 *l* 或 *l+1*。
![[Pasted image 20251231173223.png]]
**性质5**
![[Pasted image 20251231173528.png]]
节点 \* 2 = 左孩子


## 二叉树的储存结构

### 顺序储存结构
适用于完全二叉树
```cpp
typedef char TElemType;
typedef TElemType SqBiTree[MAXSIZE];
SqBiTree bt;
```
![[Pasted image 20260102160135.png]]


### 链式存储结构

分为 **二叉链表** 和 **三叉链表**
![[Pasted image 20260102160542.png]]
```cpp
// 二叉链表
typedef struct BiTNode {
    TElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

## 遍历二叉树

实质是将二叉树线性化

```cpp
// 中序遍历二叉树（递归）
void InOrderTraverse(BiTree bt) {
    if (bt) {
        InOrderTraverse(bt->lchild);
        std::cout << bt->data << ' ';
        InOrderTraverse(bt->rchild);
    }
}

// 中序遍历二叉树（工作栈）
void InOrderTraverse_stack(BiTree bt) {
    StackInit(S); BiTNode *p = bt, *q;
    while(p || !S.isempty()) {
        if (p) {
            S.push(p);
            p = p->lchild;
        }
        else {
            S.pop(q);
            cout << q->data;
            p = q->rchild;
        }
    }
}

// 层次遍历算法，使用队列完成
void LevelOrder(BiTree bt) {
    if (bt == nullptr) {
        return;
    }
    BiTNode *p;
    initQueue(q);
    enQueue(q, bt);
    while (!q.isEmpty()) {
        deQueue(q, p);
        std::cout << p->data;
        if (p->lchild)
            enQueue(q, p->lchild);
        if (p->rchild)
            enQueue(q, p->rchild);
    }
}
```
时间复杂度：*O(n)*

还有先序遍历，后序遍历，区别在于输出数据的位置不同，但是遍历顺序一致
![[Pasted image 20260102163943.png]]

反过来，可以由 先序+中序 或 后序+中序 序列，确定二叉树
方法：
- 先序：根在首；后序：根在尾
- 由根，结合中序，判断其它节点相对的左右位置
- 递归思想，继续划分新的二叉树，判断根节点，相对位置

### 应用

**先序顺序建立二叉树**

```cpp
// 先序顺序建立二叉树
void CreateBiTree(BiTree &bt) {
    TElemType e;
    std::cin >> e;
    if (e != '#') {
        bt = new BiTNode;
        bt->data = e;
        CreateBiTree(bt->lchild);
        CreateBiTree(bt->rchild);
    }
    else {
        bt = nullptr;
    }
}
```
例如：
![[Pasted image 20260103141858.png]]
输入顺序：ABC##DE#G##F###

**复制二叉树**

```cpp
// 复制二叉树
void CopyBiTree(BiTree &copy, BiTree bt) {
    if (bt) {
        copy = new BiTNode;
        copy->data = bt->data;
        CopyBiTree(copy->lchild, bt->lchild);
        CopyBiTree(copy->rchild, bt->rchild);
    }
    else {
        copy = nullptr;
    }
}
```

**统计深度和节点数**

```cpp
// 计算二叉树的深度
int Depth(BiTree bt) {
    if (bt) {
        int ldepth = Depth(bt->lchild);
        int rdepth = Depth(bt->rchild);
        return 1 + (ldepth > rdepth ? ldepth : rdepth);
    }
    else {
        return 0;
    }
}

// 统计节点个数
int Count(BiTree bt) {
    if (bt) {
        return 1 + Count(bt->lchild) + Count(bt->rchild);
    }
    else {
        return 0;
    }
}
```

## 线索二叉树

在有空指针域的节点存放二叉树顺序序列的前驱和后继
```cpp
// 线索二叉树
typedef struct BiThrNode {
    TElemType data;
    struct BiThrNode *lchild, *rchild;
    int ltag, rtag;   // 为0表示指针域指向孩子，为1表示指向前驱/后继
} BiThrNode, *BiThrTree;
```
增设一个头节点 `thrt`，其左孩子指向根节点，右孩子指向序列末节点
![[Pasted image 20260104143518.png]]

线索化
```cpp
// 二叉树线索化(中序)
BiThrNode *pre = nullptr;
void InThreading(BiThrTree p) {
    if (p) {

        // 当前节点左孩子线索化
        if (p->lchild) {
            p->ltag = 0;
            InThreading(p->lchild);
        }
        else {
            p->ltag = 1;
            p->lchild = pre;  // pre为全局变量，初始为nullptr
        }

        // 前驱节点右孩子线索化
        if (pre && !pre->rchild) {
            pre->rtag = 1;
            pre->rchild = p;
        }
        else
            pre->rtag = 0;

        // 更新pre
        pre = p;
        if (p->rchild)
            InThreading(p->rchild);
    }
}

// 带头节点的二叉树线索化
void InOrderThreading(BiThrTree &thrt, BiThrTree p) {
    thrt->ltag = 0;
    thrt->rtag = 1;
    thrt->rchild = thrt;  // 初始时指向自己，可以防止线索化中右指针改变
    if (!p) {
        thrt->lchild = thrt;
    }
    else {
        thrt->lchild = p;
        pre = thrt;
        InThreading(p);
        pre->rtag = 1;
        pre->rchild = thrt;
        thrt->rchild = pre;
    }
}
```

线索二叉树的遍历
```cpp
// 线索二叉树的遍历
void InOrderTraverse(BiThrTree thrt) {
    BiThrNode *p = thrt->lchild;
    while (p != thrt) {
        while (p->ltag == 0) {
            p = p->lchild;
        }
        std::cout << p->data;

        while (p->rtag == 1) {
            p = p->rchild;
            std::cout << p->data;
        }
        p = p->rchild;
    }
}
```
时间复杂度 *O(n)* ，空间复杂度 *O(1)* 

# 树和森林

## 树的储存结构

**1 双亲表示法**
![[Pasted image 20260105210125.png]]
**2 孩子表示法**
![[Pasted image 20260105210332.png]]
![[Pasted image 20260105210348.png]]
**3 孩子兄弟法（二叉树表示法）**
```cpp
// 树的二叉树结构定义
typedef struct CSNode {
    TElemType data;
    struct CSNode *child, *nextsibing;
} CSNode, *CSTree;
```

## 森林和二叉树的转换

树的根节点对应二叉树的右子树必空，若非空，可表示森林
![[Pasted image 20260105212415.png]]

## 树和森林的遍历

**树**：

![[Pasted image 20260105213549.png]]

**森林**：

把森林分为三部分：
![[Pasted image 20260105214451.png]]

先序：1 -> 2 -> 3
中序：2 -> 1 -> 3
