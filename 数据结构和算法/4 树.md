![[Pasted image 20251230160749.png]]
![[Pasted image 20251230160810.png]]

# 术语

结点
根节点
结点的度：结点拥有的子树数
树的度：树内所有结点的度的最大值
叶子（终端节点）： 度为0
双亲 孩子 祖先 子孙 兄弟 堂兄弟
![[Pasted image 20251230161857.png]]
树的深度：最大层次数

有序树/无序树
森林：m>=0棵不相交的树的集合
	一棵树可以看作一个特殊的森林
	给森林中的各个子树加上一个双亲节点，森林就变成了树

# 二叉树

**二叉树**：最简单、规律性强，可以由普通树转化而来
	左子树 / 右子树，次序不能颠倒，即便只有一个子树
	![[Pasted image 20251230162915.png]]
	![[Pasted image 20251230163013.png]]
	二叉树不是树的特殊情况

## 二叉树的性质

![[Pasted image 20251231172654.png]]
![[Pasted image 20251231172727.png]]
完全二叉树的特点：
- 叶子只在最后两层出现
- 若某一结点右分支子孙最大层次为 *l*，则左分支子孙最大层次为 *l* 或 *l+1*。
![[Pasted image 20251231173223.png]]
**性质5**
![[Pasted image 20251231173528.png]]
节点 \* 2 = 左孩子


## 二叉树的储存结构

### 顺序储存结构
适用于完全二叉树
```cpp
typedef char TElemType;
typedef TElemType SqBiTree[MAXSIZE];
SqBiTree bt;
```
![[Pasted image 20260102160135.png]]


### 链式存储结构

分为 **二叉链表** 和 **三叉链表**
![[Pasted image 20260102160542.png]]
```cpp
// 二叉链表
typedef struct BiTNode {
    TElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

## 遍历二叉树

实质是将二叉树线性化

```cpp
// 中序遍历二叉树（递归）
void InOrderTraverse(BiTree bt) {
    if (bt) {
        InOrderTraverse(bt->lchild);
        std::cout << bt->data << ' ';
        InOrderTraverse(bt->rchild);
    }
}

// 中序遍历二叉树（工作栈）
void InOrderTraverse_stack(BiTree bt) {
    StackInit(S); BiTNode *p = bt, *q;
    while(p || !S.isempty()) {
        if (p) {
            S.push(p);
            p = p->lchild;
        }
        else {
            S.pop(q);
            cout << q->data;
            p = q->rchild;
        }
    }
}
```
时间复杂度：*O(n)*

还有先序遍历，后序遍历，区别在于输出数据的位置不同，但是遍历顺序一致
![[Pasted image 20260102163943.png]]

反过来，可以由 先序+中序 或 后序+中序 序列，确定二叉树
方法：
- 先序：根在首；后序：根在尾
- 由根，结合中序，判断其它节点相对的左右位置
- 递归思想，继续划分新的二叉树，判断根节点，相对位置

### 应用

**先序顺序建立二叉树**

```cpp
// 先序顺序建立二叉树
void CreateBiTree(BiTree &bt) {
    TElemType e;
    std::cin >> e;
    if (e != '#') {
        bt = new BiTNode;
        bt->data = e;
        CreateBiTree(bt->lchild);
        CreateBiTree(bt->rchild);
    }
    else {
        bt = nullptr;
    }
}
```
例如：
![[Pasted image 20260103141858.png]]
输入顺序：ABC##DE#G##F###

**复制二叉树**

```cpp
// 复制二叉树
void CopyBiTree(BiTree &copy, BiTree bt) {
    if (bt) {
        copy = new BiTNode;
        copy->data = bt->data;
        CopyBiTree(copy->lchild, bt->lchild);
        CopyBiTree(copy->rchild, bt->rchild);
    }
    else {
        copy = nullptr;
    }
}
```

**统计深度和节点数**

```cpp
// 计算二叉树的深度
int Depth(BiTree bt) {
    if (bt) {
        int ldepth = Depth(bt->lchild);
        int rdepth = Depth(bt->rchild);
        return 1 + (ldepth > rdepth ? ldepth : rdepth);
    }
    else {
        return 0;
    }
}

// 统计节点个数
int Count(BiTree bt) {
    if (bt) {
        return 1 + Count(bt->lchild) + Count(bt->rchild);
    }
    else {
        return 0;
    }
}
```