# 术语和概念

**图** G = (V, E)
- V：顶点：有穷非空集合
- E：边的有穷集合
**无向图**：边无方向
**有向图**：边有方向

**完全图**：任意两个顶点都有边连接
![[Pasted image 20260108135633.png]]

![[Pasted image 20260108135918.png]]

**顶点的度**：与某个顶点关联的边数，记作TD(v)
* 有向图中：
	- 入度：ID(v)
	- 出度：OD(v)

**有向图中仅有一个顶点的入度为0，其余为1是，它为有向树**

**路径**：接续的边构成的顶点序列
**路径长度**：路径上边或弧的数目/权值之和
**回路（环）**：首顶点和尾顶点相同的路径
**简单路径**：顶点和终点之外，其余顶点不同的路径
**简单回路（环）**：顶点和终点相同，其余顶点不同的路径

**（强）连通图**：任何两个顶点之间都有路径

**子图**：
![[Pasted image 20260108141509.png]]

**连通分量**：无向图G的**极大连通子图**
![[Pasted image 20260108141854.png]]

**强连通分量**：有向图G的**极大强连通子图**
![[Pasted image 20260108142051.png]]

**极小连通子图**：边不能再少

**生成树**：包含所有顶点的极小连通子图
**生成森林**：对非连通图，各个连通分量的生成树集合
![[Pasted image 20260108142527.png]]


# 图的储存结构

没有顺序存储结构
使用链式存储结构

## 邻接矩阵表示法

用矩阵表示各个顶点之间的关系
![[Pasted image 20260109135652.png]]
![[Pasted image 20260109135739.png]]

入度 = 第 i 行权值数
出度 = 第 i 列权值数

```cpp
#define MaxInt 32767 // 极大值
#define MVNum 80   // 最大顶点数

typedef char VerTexType;  // 顶点的数据类型
typedef int ArcType;  // 边的权值类型

typedef struct {
    VerTexType vexs[MVNum];  // 顶点表
    ArcType arcs[MVNum][MVNum];  // 邻接矩阵
    int vexnum, arcnum;  // 点数和边数
} AMGraph;
```

注意：图中没有重复的顶点

**优缺点**：

![[Pasted image 20260109142339.png]]

## 邻接表表示法

为每个顶点建立一个单链表，储存邻接顶点
![[Pasted image 20260110135753.png]]
边节点的邻接节点域(adjvex)指示邻接节点的位置

![[Pasted image 20260110140455.png]]
![[Pasted image 20260110140936.png]]
无向图中
- 如果有 n 个节点 e 条边，那么表头节点数为 n ，边界点数为 2e
- 顶点的度 = 边节点数
有向图中
- 顶点的出度 = 边节点数
- 顶点的入度 = 整个单链表中邻接点域值为 i-1 的节点数

```cpp
// 邻接表表示法
// 边
typedef struct ArcNode {
    int adjvex;   // 边指向的顶点
    struct ArcNode *nextarc;
    int info;  // 和边相关的信息
} ArcNode;

// 顶点
typedef struct VNode {
    VerTexType data;
    ArcNode *firstarc;
} VNode, AdjList[MVNum];

// 表
typedef struct {
    AdjList vertices;
    int vexnum, arcnum;
} ALGraph;
```

```cpp
// 创建无向图
void createALGraph(ALGraph &G) {
    std::cin >> G.vexnum >> G.arcnum;

    // 构造节点
    for (int i = 0; i < G.vexnum; i++) {
        std::cin >> G.vertices[i].data;
        G.vertices[i].firstarc = nullptr;   // 置空
    }

    // 构造边
    for (int i = 0; i < G.arcnum; i++) {
        int v1, v2;
        std::cin >> v1 >> v2;
        
        // 头插法连接边界点和顶点
        ArcNode *arc1 = new ArcNode;
        arc1->nextarc = G.vertices[v1].firstarc;
        G.vertices[v1].firstarc = arc1;
        arc1->adjvex = v2;
        
        ArcNode *arc2 = new ArcNode;
        arc2->nextarc = G.vertices[v2].firstarc;
        G.vertices[v2].firstarc = arc2;
        arc2->adjvex = v1;
    }
}
```

时间复杂度：*O(n)*

注意：图的邻接矩阵表唯一，邻接表不唯一

![[Pasted image 20260111143408.png]]

![[Pasted image 20260112205259.png]]
## 十字链表表示法

![[Pasted image 20260112210345.png]]

## 邻接多重表

![[Pasted image 20260112211057.png]]


# 图的遍历

图存在回路，可能会经过某个顶点多次

**避免重复访问的方法**：
设置辅助数组，记录被访问的顶点

**遍历方法**：

## 深度优先（DFS）

从一点出发，访问未访问的邻接点，若没有，退一步，重复
![[Pasted image 20260113091104.png]]

```cpp
// 邻接矩阵连通图的DFS
bool visited[MVNum] = {false};
void DFS(AMGraph *g, int start) {
    std::cout << g->vexs[start];
    visited[start] = true;
    for (int i = 1; i < g->vexnum; i++) {
        if (g->arcs[start][i] != 0 && visited[i] == false)
            DFS(g, i);
    }
}

// 非联通图
void DFSTraverse(AMGraph *g) {
    for (int i = 0; i < g->vexnum; i++) {
        if (visited[i] == false) {
            DFS(g, i);
        }
    }
}

// 邻接表连通图的DFS
void DFS(ALGraph *g, int start) {
    std::cout << g->vertices[start].data;
    visited[start] = true;
    ArcNode *p = g->vertices[start].firstarc;
    while (p) {
        int i = p->adjvex;
        if (visited[i] == false) {
            DFS(g, i);
        }
        p = p->nextarc;
    }
}
```
使用邻接矩阵的DFS算法时间复杂度为：*O(n^2)*
邻接表：*O(n + e)*

## 广度优先（BFS）

先访问一个点的邻接点，再依次访问邻接点的邻接点

```cpp
// BFS
void BFS(ALGraph *g, int start) {

    // 先访问，后入队
    visited[start] = true;
    std::cout << g->vertices[start].data;
    initQueue(q);
    enQueue(q, start);

    while (!q.isEmpty()) {
        int j;
        Dequeue(q, j);

        // 遍历 j 的邻接点
        ArcNode *p = g->vertices[j].firstarc;
        while(p) {
            int i = p->adjvex;
            if (visited[i] == true)
                continue;
            visited[i] = true;
            std::cout << g->vertices[i].data;
            enQueue(q, i);

            p = p->nextarc;
        }
    }
}
```

# 图的引用

## 最小生成树

**生成树的定义**
所有顶点都用边连上，且没有回路

**生成树的特点**
- 生成树是图的极小连通图
- n个顶点的生成树，一定有(n-1)条边
- 生成树再加一条边必然产生回路

**构造思路**
![[Pasted image 20260114091126.png]]


**最小生成树的定义**
给定一个无向网，所有生成树中，各边权值之和最小的生成树，也叫**最小代价树**

**MST性质**
![[Pasted image 20260114092951.png]]