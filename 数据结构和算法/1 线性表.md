# 定义和特点
有相同性质数据元素的有限序列
![[Pasted image 20251203135551.png]]
n=0时为空表
数据元素之间的关系为线性关系

# 类型定义
![[Pasted image 20251203141111.png]]
先明确逻辑结构，确定存储结构之后才能代码实现

# 顺序存储结构
逻辑上相邻 --》 物理上相邻，存储地址连续
可运用等差数列，知道一个元素地址和存储单元数量，其他元素的地址也都能得出

```cpp
#include<iostream>

#define MAXSIZE 100
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2


typedef char ElemType;
typedef int Status;

typedef struct {
    ElemType *elem;
    int length;
} SqList;

// 初始化
Status InitList_Sq(SqList &L) {
    L.elem = new ElemType[MAXSIZE];
    if(!L.elem) exit(OVERFLOW);
    L.length = 0;
    return OK;
}

// 销毁
void DestroyList(SqList &L) {
    if (L.elem) {
        delete[] L.elem;  //pay attention to []：new[] 和 delete[] 是成对使用的
        L.elem = NULL;
    }
    L.length = 0;
}

// 索引取值
Status GetElem(SqList &L, int i, ElemType &e) {
    if (i<1 || i>L.length) {
        return ERROR;
    }
    e = L.elem[i-1];
    return OK;
}

// 查找
int LocateElem(SqList &L, ElemType &e) {
    for (int i=0; i<L.length; i++) {
        if (L.elem[i] == e){
            return i+1;
        }
    }
    return ERROR;
}

// 插入
Status InsertElem(SqList &L, int i, ElemType &e) {
    if (i<1 || i>L.length+1 || L.length == MAXSIZE) {
        return ERROR;
    }
    L.length++;
    for (int j=L.length-1; j>=i; j--) {
        L.elem[j] = L.elem[j-1];
    }
    L.elem[i-1] = e;
    return OK; 
}

// 删除
Status DeleteElem(SqList &L, int i, ElemType &e) {
    if (i<1 || i>L.length) {
        return ERROR;
    }
    for (int j=i-1; j<L.length-1; j++) {  // 注意j只遍历到倒数第2个元素
        L.elem[j] = L.elem[j+1];
    }
    L.length--;
    return OK; 
}

```

## 查找
平均查找长度（ASL）= （length+1)/2
## 插入
![[Pasted image 20251204150634.png]]
## 删除
![[Pasted image 20251204152246.png]]
## 总结
![[Pasted image 20251204152209.png]]
![[Pasted image 20251204152442.png]]

# 链式存储结构

**节点**由**数据域**和**指针域**组成，若每个节点只包含一个指针域，则称为**线性链表**或**单链表**，由表头指针确定和命名
```c
typedef struct LNode
{
	ElemType data;     //数据域
	struct LNode *next;//指针域
}LNode, *LinkList;
```
`LinkList L` 等价于 `LNode *L`
![[Pasted image 20251206141755.png]]
增加头节点作用：
- 便于首元素管理
- 便于处理空表

## 单链表
```cpp
// 单链表的初始化
Status InitList(LinkList &L) //注意L是指针
{
    L = new LNode;
    L->next = NULL;
    return OK;
}
```

```cpp
// 根据序号取值
Status GetElem(LinkList &L, int i, ElemType &e)
{
    int j = 1;
    LinkList p = L->next; //不要修改头指针L的值
    while (p && j < i) {  //不可以把p->next作为判据，那样不能处理空链表
        p = p->next;
        ++j;
    }
    if (!p || j>i)  // p为空值（i太大）或i<1
        return ERROR;
    e = p->data;
    return OK;
}
```
![[Pasted image 20251206145240.png]]

```cpp
// 根据数据查找
LNode* LocateElem(LinkList &L, ElemType e) {
    LNode* p = L->next;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;  // 查找成功，返回数据地址，否则返回NULL
}
```

```cpp
// 插入
Status InsertElem(LinkList &L, int i, ElemType e) {
    int j = 0;    //注意初始从头节点开始
    LNode* p = L; //注意初始从头节点开始，以便能在首元素位置插入
    while (p && j<i-1) {
        j++;
        p = p->next;
    }
    if (!p || j>i-1)
        return ERROR;
    LNode* node = new LNode;
    node->data = e;
    node->next = p->next;
    p->next = node;
    return OK;
}
```

```cpp
// 按序号删除
Status ListDelete(LinkList &L, int i) {
    LNode* p = L;
    int j = 0;
    while (p->next && j<i-1) {  //注意要检查p的下一个节点而不是p节点
        p = p->next;
        j++;
    }
    if (!p->next || j>i-1) {
        return ERROR;
    }
    LNode *q = p->next;
    p->next = q->next;
    delete q;
    return OK;
}
```
两者都要先定位到 i-1 处
插入的前提：i-1 要存在
删除的前提：i 要存在
```cpp
// 前插法创建单链表
void CreatList_H(LinkList &L, int n) {
    L = new LNode;
    L->next = nullptr;
    for (int i=0; i<n; i++) {
        LNode *p = new LNode;
        p->next = L->next;
        L->next = p;
        std::cin >> p->data;
    }
}

// 后插法创建单链表
void CreatList_R(LinkList &L, int n) {
    L = new LNode;
    L->next = nullptr;
    LNode *r = L;
    for (int i=0; i<n; i++) {
        LNode *p = new LNode;
        std::cin >> p->data;
        r = (r->next = p);
    }
    r->next = nullptr;
}
```

## 循环链表

最后一个指针域指向头节点

判断遍历完成的条件：
`p != L`
`p->next != L`

![[Pasted image 20251211105451.png]]
有时 设置**尾指针**而不是头指针，更方便

头指针：
	L 指向头节点
	L->next 指向首元节点
尾指针：
	R 指向最后一个节点
	R->next 指向头节点
	R->next->next 指向首元节点
	
如合并两个表：
1）表B的尾指针指向A的头节点
2）表A的尾指针指向B的首元节点
![[Pasted image 20251211105708.png]]

## 双向链表

可以直接查找后继和前驱
```cpp
// 双向链表
typedef struct DuLNode{
    ElemType Data;
    struct DuLNode *prior;
    struct DuLNode *next; 
}DuLNode, *DuLinkList;
```
也存在双向循环链表
![[Pasted image 20251211111253.png]]

```cpp
// 双向链表的查找
DuLNode* GetElem_DuL(const DuLinkList& L, int i) {
    int j = 1;
    DuLNode* p = L->next;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    if (!p || j != i) {
        return nullptr;
    }
    return p;
}
```

插入和删除时需要修改4个、2个指针
同时注意检查第 i 个元素的后继节点是否存在
```cpp
// 双向链表插入
Status ListInsert_DuL(DuLinkList& L, int i, const ElemType& e) {
    int j = 0;
    DuLNode *p = L;
    while (p && j < i-1) {
        p = p->next;
        j++;
    }
    if (!p || j > i-1) {
        return ERROR;
    }
    DuLNode *q = p->next;
    DuLNode *n = new DuLNode;
    n->Data = e;

    p->next = n;
    n->prior = p;
    n->next = q;

    if (q) {
        q->prior = n;
    }
    return OK;
}

// 双向链表的删除
Status ListDelete_DuL(DuLinkList& L, int i) {
    DuLNode* p = GetElem_DuL(L, i);
    if (!p)
        return ERROR;
    p->prior->next = p->next;
    if (p->next)
        p->next->prior = p->prior;
    delete p;
    return OK;
}
```
插入：第 i-1 个节点存在
删除：第 i 个节点存在

# 两种存储结构的比较

**顺序表——查快改慢；链表——查慢改快**

| **比较维度**       | **顺序表（Sequential List）**             | **链表（Linked List）**                  |
| -------------- | ------------------------------------ | ------------------------------------ |
| **存储方式**       | 连续内存空间（如数组）                          | 非连续内存，通过指针链接结点                       |
| **是否需预分配空间**   | 是（大小固定，易溢出或浪费）                       | 否（动态申请，灵活扩展）                         |
| **存储密度**       | 高（=1，无额外开销）                          | 低（<1，每个结点含指针域，占用额外空间）                |
| **随机访问（按位取值）** | 支持，时间复杂度 **O(1)**                    | 不支持，需从头遍历，时间复杂度 **O(n)**             |
| **插入/删除操作**    | 需移动大量元素，平均 **O(n)**                  | 仅修改指针（找到位置后），**O(1)**                |
| **适用场景**       | - 长度稳定  <br>- 主要操作为查找/访问  <br>- 内存受限 | - 长度变化大  <br>- 频繁插入/删除  <br>- 难以预估规模 |
| **优点**         | - 访问快  <br>- 缓存友好（局部性好）  <br>- 节省内存  | - 动态伸缩  <br>- 插入/删除高效  <br>- 无需连续内存  |
| **缺点**         | - 插入/删除慢  <br>- 固定容量  <br>- 可能溢出或浪费  | - 访问慢  <br>- 指针开销大  <br>- 不支持随机访问    |
# 应用

## 线性表的合并
```cpp
// 线性表的合并
void MergeList(LinkList& A, const LinkList& B) {
    int m = ListLength(A);
    int n = ListLength(B);
    for (int i = 1; i <= n; i++) {
        ElemType e;
        GetElem(B, i, e);
        if (!LocateElem(A, e))
            ListInsert(A, ++m, e);
    }
}
```
时间复杂度：*O* (*m* × *n*)

## 有序表的合并

```cpp
// 顺序有序表的合并，不改变原表(伪代码)
void MergeList_SQ(const SQList& LA, const SQList& LB, SQList& LC) {
	LC.length = LA.length + LB.length;
	LC.elem = new ElemType[LC.length];
	pc = LC.elem; pa...; pb...;  // pa pb pc 都是指向首元素的指针
	pc_last = LC.elem + LC.length - 1; pa_last...; pb_last...;
	while (pa <= pa_last && pb <= pb_last) {  //pa < LA.elem + LA.length更常见
		if (*pa <= *pb) {
			*(pc++) = *(pa++);  // 这种同时递增同时赋值的写法可以学习
		}
		else {
			*(pc++) = *(pb++);
		}
	}
	while (pa <= pa_last) {
		*(pc++) = *(pa++);
	}
	while (pb <= pb_last) {
		*(pc++) = *(pb++);
	}
}
```
时间复杂度：O(m + n)
空间复杂度：O(m + n)

## 有序链表合并
```cpp
// 有序链表的合并，清空原表
void MergeList_L(LinkList& LA, LinkList& LB, LinkList& LC) {
    LNode* pa = LA->next;
    LNode* pb = LB->next;
    LC = LA;
    LNode* pc = LC;

    while (pa && pb) {
        if (pa->data <= pb->data) {
            pc->next = pa;
            pc = pc->next;
            pa = pa->next; 
        }
        else {
            pc->next = pb;
            pc = pc->next;
            pb = pb->next;
        }
    }
    pc->next = pa ? pa : pb; // 这里要体会体会，直接接上即可，不需要循环
    // ↓处不建议这样
    delete LB;
    LB = nullptr;
    LA = nullptr;
    // ↓更推荐：清空 LB 和 LA 的 next，表示它们的内容已被转移
    LB->next = nullptr;
    LA->next = nullptr;  // 可选：表明 LA 已“交出”所有数据结点
    // ❌ 不要 delete LB 或 LA！
    // 调用者负责释放头结点（如果它们是动态分配的）
}
```
时间复杂度：O(m + n)
空间复杂度：O(1)

# 案例

## 多项式
```cpp
#include <iostream>
using namespace std;

typedef struct PNode{
    float coef; // 系数
    int expn;   // 指数
    struct PNode *next;
} PNode, *Polynomial;

// 创建多项式链表，有头节点，输入的指数不可以重复，升序
void createPolynomial(Polynomial &Poly, int n) {
    Poly = new PNode;
    Poly->next = nullptr;

    while (n-- > 0) {
        PNode *p = new PNode;
        cin >> p->coef >> p->expn;

        PNode *poly = Poly;  // 用于标定插入新节点的前一个位置
        while (poly->next && poly->next->expn < p->expn) {
            poly = poly->next;
        }
        p->next = poly->next;
        poly->next = p;
    }
}

// 多项式相加，把B加到A上
void addPolynomial(Polynomial &A, Polynomial &B) {
    PNode *pa = A;  // 标定相加项位置的前一项，可能涉及插入，删除操作
    PNode *pb = B->next;
    while (pa->next && pb) {
        if (pa->next->expn < pb->expn) {
            pa = pa->next;
        }
        else if (pa->next->expn > pb->expn){
            PNode *large = pa->next;
            PNode *small = pb;
            pb = pb->next;
            pa->next = small;
            small->next = large;
            pa = pa->next;
        }
        
        else {
            float sum = pa->next->coef + pb->coef;

            // 要区分 sum 是否为 0
            if (sum) {
                pa->next->coef = sum;
                pa = pa->next;
                PNode *dell = pb;
                pb = pb->next;
                delete dell;
            }
            else {
                PNode *dell = pa->next;
                pa->next = dell->next;
                delete dell;
                dell = pb;
                pb = pb->next;
                delete dell;
            }
        }
    }
    if (!pa)
        pa->next = pb;
    B->next = nullptr;
}

void showPloynomial(const Polynomial &P) {
    PNode *p = P->next;
    while (p) {
        printf("(%.1f, %d)  ", p->coef, p->expn);
        p = p->next;
    }
    cout << endl;
}

int main() {
    Polynomial a;
    Polynomial b;
    createPolynomial(a, 3);
    showPloynomial(a);
    createPolynomial(b, 5);
    showPloynomial(b);
    addPolynomial(a, b);
    showPloynomial(a);
}
```

时间复杂度：O(m + n)
空间复杂度：O(1)