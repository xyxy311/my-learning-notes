另一种编程思想：泛型编程
模板分为 函数模板 类模板
语法： 
`template<typename T>`
`template <typename T, int N>`
`template <typename T1, typename T2>`
	T 为类型名，可以替换

# 函数模板

```cpp
#include<iostream>
using namespace std;

template<typename T>
void swapab(T &a, T &b) {
	T temp = a;
	a = b;
	b = temp;
}

int main(){
	int a=1, b=2;
	// 自动类型推导
	swapab(a, b);
	// 显式指定类型
	swapab<int>(a, b);
	
	cout << a << ' ' << b;
}
```

**注意**：
模板必须确定类型才能使用，即便函数中没有用到 T
模板自动推导类型时，不存在隐式类型转换
显式指定类型后，函数模板类似于普通函数，可以发生隐式转换
函数模板可以重载

**调用规则**：
优先调用普通函数，但是如果模板产生更好的匹配（如调用普通函数时需要隐式转换），则优先调用模板
通过空模板的参数列表，即`<>`，可以强制调用模板

# 类模板

和函数模板类似

```cpp
template<typename NameType = string, typename AgeType = int>
class Person {
	public:
		NameType name;
		AgeType age;
		
		Person(NameType name, AgeType age) {
			this->name = name;
			this->age = age;
		}

		void showIFO() {
			cout << name << ' ' << age;
		}
};

int main(){
	Person<string, int> dog("狗子", 15);
	dog.showIFO();
}
```
- 类模板在C++之前不支持自动类型推导，之后支持，所以可以这样写：
	`Person dog("狗子", 15);`
- 类模板支持默认参数
- 类模板中的成员函数在调用时才会创建，和普通类不一样，因为只有在调用时才知道T是什么类型
## 类模板的三种传参方式

1. 直接指定类型
2. 类型模板化
3. 类模板化
```cpp
void printInfo(Person<string, int> &p) {}

template<class T1, class T2>
void printInfo(Person<T1, T2> &p) {}

template<class T>
void printInfo(T &p) {}
```

## 类模板的继承

- 子类继承带有模板的父类时，需要指定类型，否则，编译器无法为其分配内存
- 可以把子类也变为模板，这样可以灵活地继承

```cpp
#include<iostream>
#include<string>
using namespace std;

template<class T>
class Base {
	public:
		T Bname;
};

// 继承方法一
class Son1: public Base<char> {
	public:
		Son1() {
			cout << typeid(Bname).name() << endl;
		}
};

// 继承方法二
template<class T1, class T2>
class Son2: public Base<T1> {
	public:
		T2 Sname;
		Son2() {
			cout << typeid(this->Bname).name() << endl;
			cout << typeid(Sname).name() << endl;
		}
};

int main(){
	Son1 son1;
	Son2<int, char> son2;
}

/*
输出: 
c
i
c
*/
```

## 类内函数的类外实现

```cpp
template<class T1, class T2>
class Base {
	public:
		Base(T1, T2);
		void fuc1(T1, T2);
};

template<class T1, class T2>
Base<T1, T2>::Base(T1 a, T2 b) { ... }

template<class T1, class T2>
void Base<T1, T2>::fuc(T1 a, T2 b) { ... }
```

## 类模板分文件编写

类模板中的成员在调用时创建，导致链接多文件时无法识别到函数实现

解决方法：
- 直接包含.cpp文件（不推荐）
- 将声明和实现写在同一个文件中，后缀名改为.hpp

## 类模板的友元函数

建议直接在类中定义友元函数的实现