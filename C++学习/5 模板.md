另一种编程思想：泛型编程
模板分为 函数模板 类模板
语法： 
`template<typename T>`
`template <typename T, int N>`
`template <typename T1, typename T2>`
	T 为类型名，可以替换

# 函数模板

```cpp
#include<iostream>
using namespace std;

template<typename T>
void swapab(T &a, T &b) {
	T temp = a;
	a = b;
	b = temp;
}

int main(){
	int a=1, b=2;
	// 自动类型推导
	swapab(a, b);
	// 显式指定类型
	swapab<int>(a, b);
	
	cout << a << ' ' << b;
}
```

**注意**：
模板必须确定类型才能使用，即便函数中没有用到 T
模板自动推导类型时，不存在隐式类型转换
显式指定类型后，函数模板类似于普通函数，可以发生隐式转换
函数模板可以重载

**调用规则**：
优先调用普通函数，但是如果模板产生更好的匹配（如调用普通函数时需要隐式转换），则优先调用模板
通过空模板的参数列表，即`<>`，可以强制调用模板

# 类模板

和函数模板类似

```cpp
template<typename NameType = string, typename AgeType = int>
class Person {
	public:
		NameType name;
		AgeType age;
		
		Person(NameType name, AgeType age) {
			this->name = name;
			this->age = age;
		}

		void showIFO() {
			cout << name << ' ' << age;
		}
};

int main(){
	Person<string, int> dog("狗子", 15);
	dog.showIFO();
}
```
- 类模板在C++之前不支持自动类型推导，之后支持，所以可以这样写：
	`Person dog("狗子", 15);`
- 类模板支持默认参数
- 类模板中的成员函数在调用时才会创建，和普通类不一样，因为只有在调用时才知道T是什么类型
## 类模板的三种传参方式

1. 直接指定类型
2. 类型模板化
3. 类模板化
```cpp
void printInfo(Person<string, int> &p) {}

template<class T1, class T2>
void printInfo(Person<T1, T2> &p) {}

template<class T>
void printInfo(T &p) {}
```

## 类模板的继承

- 子类继承带有模板的父类时，需要指定类型，否则，编译器无法为其分配内存
- 可以把子类也变为模板，这样可以灵活地继承

```cpp
#include<iostream>
#include<string>
using namespace std;

template<class T>
class Base {
	public:
		T Bname;
};

// 继承方法一
class Son1: public Base<char> {
	public:
		Son1() {
			cout << typeid(Bname).name() << endl;
		}
};

// 继承方法二
template<class T1, class T2>
class Son2: public Base<T1> {
	public:
		T2 Sname;
		Son2() {
			cout << typeid(this->Bname).name() << endl;
			cout << typeid(Sname).name() << endl;
		}
};

int main(){
	Son1 son1;
	Son2<int, char> son2;
}

/*
输出: 
c
i
c
*/
```

## 类内函数的类外实现

```cpp
template<class T1, class T2>
class Base {
	public:
		Base(T1, T2);
		void fuc1(T1, T2);
};

template<class T1, class T2>
Base<T1, T2>::Base(T1 a, T2 b) { ... }

template<class T1, class T2>
void Base<T1, T2>::fuc(T1 a, T2 b) { ... }
```

## 类模板分文件编写

类模板中的成员在调用时创建，导致链接多文件时无法识别到函数实现

解决方法：
- 直接包含.cpp文件（不推荐）
- 将声明和实现写在同一个文件中，后缀名改为.hpp

## 类模板的友元函数

建议直接在类中定义友元函数的实现

## 实例（自定义列表）
```cpp
#include <iostream>
using namespace std;

template <typename ElemType>
class MyArray {
	public:
		MyArray(int capacity) {
			this->pArray = new ElemType[capacity];
			this->capacity = capacity;
		}
		~MyArray() {
			if (this->pArray != nullptr) {
				delete[] this->pArray;
			}
			this->pArray = nullptr;
		}

		// 拷贝构造函数
		MyArray(const MyArray &ori) {
			this->capacity = ori.capacity;
			this->size = ori.size;
			this->pArray = new ElemType[ori.capacity];
			for (int i = 0; i < this->size; i++) {
				this->pArray[i] = ori.pArray[i];
			}
		}
		
		// =运算符重载为深拷贝版本
		MyArray& operator=(const MyArray &ori) {
			if (this->pArray) {
				delete[] this->pArray;
			}
			this->capacity = ori.capacity;
			this->size = ori.size;
			this->pArray = new ElemType[ori.capacity];
			for (int i = 0; i < this->size; i++) {
				this->pArray[i] = ori.pArray[i];
			}
			return *this;
		}
		// []运算符重载
		ElemType& operator[](int i) {
			if (i < 0 || i > this->size - 1) {
				exit(-1);
			}
			return this->pArray[i];
		}

		// 尾插
		void pushBack(const ElemType &e) {
			if (this->size == this->capacity) {
				return;
			}
			else {
				this->pArray[this->size++] = e;
			}
		}

		// 尾删
		void popBack() {
			if (this->size > 0) {
				this->size--;
			}
		}

		// 遍历
		void tranverse() {
			for (int i = 0; i < size; i++) {
				cout << pArray[i] << ' ';
			}
			cout << endl;
		}
	private:

		// 指向堆区开辟的区域
		ElemType *pArray;

		int capacity;
		int size;
};

int main() {

	MyArray<int> array1(5);
	for (int i=0; i<5; i++) {
		array1.pushBack(i);
	}
	array1.tranverse();
	
	array1[1] = 10;
	cout << array1[2] << endl;

	// cout << array1[5];
	array1.tranverse();
}
```

# STL 容器

广义上分为**容器**、**算法**、**迭代器**
容器和算法之间通过迭代器衔接

细分分为：**容器**、**算法**、**迭代器**、**仿函数**、**适配器（配接器）**、**空间配置器**

**容器**
存放数据
	**序列式容器**：有顺序
	**关联式容器**：无序，二叉树结构

**算法**
	**质变算法**：会改变数据
	**非质变算法**：不改变数据

**迭代器**
提供一种能够依次访问容器内元素数据 而不外露该容器的内部表示形式
每个容器都有专属迭代器
其类似指针

## vector

容器：`vector`
算法：`for_each`
迭代器：`vector<T>::iterator`

动态扩展机制：不是在原空间扩展，而是找更大的空间，释放原空间

```cpp
vector<int> v;
v.push_back(5);

vector<int>::iterator itBegin = v.begin();  // 指向首元素
vector<int>::iterator itEnd = v.end();      // 指向最后一个元素的后一位

// 遍历方式一
while (itBegin != itEnd) {
	cout << *itBegin << endl;
	itBegin++;
}

// 遍历方式二
for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
	cout << *it << endl;
}

// 遍历方式三
void print(int val) {
	cout << val << endl;
}
for_each(v.begin(), v.end(), print);

// 嵌套容器的遍历
for (vector<vector<int>>::iterator itb = vb.begin(); it != vb.end(); it++) {
	for (vector<int>::iterator its = (*itb).begin(); its != (*itb).end(); its++) {
		cout << *its << ' ';
	}
	cout << endl;
}
```

#### 构造函数

```cpp
vector<T> v1;
vector<T> v2(v1.begin(), v1.end())  // 区间内数据拷贝到v2构造
vector<T> v3(int n, T data)
vector<T> v4(v3)  // 拷贝构造
```

#### 赋值

可以使用 = 也可以 assign
```cpp
v.assign(v1.begin(), v1.end());
v.assign(int n, T data);
```

#### 容量和大小

```cpp
v.empty()  // 返回布尔值
v.capacity()
v.size()
v.resize(int n [, T data])  // 调整大小，若变大，用传入数据填补
```

#### 插入和删除

```cpp
v.push_back(T data);
v.pop_back();   // 注意它不返回pop出来的值
v.insert(const_iterator pos [, int n], T elem);  // 必须是迭代器类型
v.erase(const_iterator pos);
v.erase(const_iterator start, const_iterator end);
v.clear();
// 示例：
v.insert(v.begin() + 1, 2);
v.insert(v.begin(),5 , 3);
v.remove(elem)  // 删除所有和elem值匹配的元素
```

#### 数据存取

可以使用 `at` 和 `[]`，根据索引获取元素
也可以使用`v.front()   v.back()` 获取首/尾元素

#### 交换 vector

`v1.swap(v2)` 可以交换v1和v2的数据
可以用`vector<T>(v).swap(v)`压缩`v`容器的空间(capacity)

#### 预留空间

使用 `v.reserve(int n)`预留n个数据的空间，减少内存开辟的次数

## string

### 构造函数

```cpp
string()  // 空的字符串
string(const char *s) // 字符串构造
string(const string &str)  // 拷贝构造
string(int n, char c)  // 初始化为n个字符c 
```
### 赋值操作

- 使用 `=` 通过 `string`类、字符串、字符赋值
- 使用 `assign` 成员函数
```cpp
string s1;
s1.assign(const string &s);
s1.assign(const char *s [, int n]);  // 把字符串[的前n个字符]赋值给s
s1.assign(int n, char c);
```

### 字符串拼接

- 可以使用 +、+=
- 也可以使用`append`
```cpp
s1.append(const char *s [, int n])
s1.append(const string &s [, int pos [, int n]]);  // 从索引为pos的字符开始拼接n个字符
// 如果不指定n，则拼接到s的末尾
```

### 查找和替换

```cpp
s1.find(字符串或字符 [, int pos [, int n]])  // 从pos开始，查找传入字符类型的前n个字符首次出现的位置，若失败，则返回 -1
s1.rfind(字符串或字符 [, int pos [, int n]])
s1.replace(int pos, int n, 字符串或字符)  // 从pos开始的n个字符替换为传入字符类型
```

### 比较

```cpp
s1.compare(字符类型)
```
按照 ASCII码 比较
< : 负数
\> : 正数
\= : 0

### 字符存取

使用下面的语法获取某个位置的字符
```cpp
s[i];
s.at(i);
```

可以直接使用 `=` 对字符进行修改

### 插入和删除

```cpp
s.insert(int pos, 字符类型);
s.insert(int pos, int n, char c); //在pos处（前）插入n个c
s.erease(int pos, int n = npos)  // 删除pos开始n个字符
```

### 获取子串

```cpp
s.substr(int pos = 0, int n = npos);  // 返回从 pos 开始的 n 个字符构成的字符串
```


## deque

双向队列
相对于deque，vector 对头的处理效率低，但是访问快
![[Pasted image 20260106091806.png]]

### 构造函数

同 `vector`

补充 `const_iterator`的用法
```cpp
void printDeque(const deque<int> &q) {
	for (deque<int>::const_iterator it = q.begin(); it != q.end(); it++) {
		cout << *it;
	}
}
```

### 赋值

同 `vector`

### 大小

`deque`中无容量（`capacity`）属性
其它同 `vector`

### 插入和删除

多了`q.push_front()`、`q.pop_front()`
其它同 `vector`

### 数据存取

同 `vector`

### 排序

`sort(iterator beg, iterator end)`

```cpp
#include <iostream>
#include <deque>
#include <algorithm>

using namespace std;

void printDeque(deque<int> &q) {
    for (int i = 0; i < q.size(); i++) {
        cout << q[i] << " ";
    }
    cout << endl;
}

int main() {
	deque<int> q;
    q.push_back(1);
    q.push_back(2);
    q.push_front(3);
    q.push_front(4);
	printDeque(q);
	sort(q.begin(), q.end());
	printDeque(q);
}
```

## stack

### 接口

![[Pasted image 20260107160946.png]]

## queue

### 接口

![[Pasted image 20260107161202.png]]

## list

双向循环链表
插入和删除不会使`list`的迭代器失效，而`vector`无法保证

### 构造函数

同 `vector`

### 赋值和交换

同 `vector`

### 大小

同 `deque`

### 插入删除

同 `deque`

### 数据存取

只有`l.front()`和`l.back()`，不能随机存取
`list<int>::iterator it`只支持`it++`/ `it--`，不能使用`it = it + 1`

### 反转和排序

```cpp
list<int> l;
l.push_back(2);
l.push_back(3);
l.push_back(4);
l.push_back(22);

l.reverse();
// 不支持随机访问的容器，不能使用标准的算法，但是内部会提供对应的算法
sort(l.begin(), l.end()) 这不正确
l.sort()  // 默认从小到大

bool rule(int a, int b) {
	return a > b;
}

l.sort(rule)  // 使用仿函数自定义大小规则（这里是从大到小）

```

## set

不允许有重复元素，`multiset`允许
加入新元素时会自动排序，默认从小到大
只能用 `insert` 插入元素
### 构造和赋值

```cpp
set<T> st;
set<T> st1(st);
st1 = st;
```

### 大小和交换

```cpp
set.empty()
set.size()
set.swap(set1)
```
不支持`resize()`

### 插入和删除

```cpp
set.insert(1);  // 插入时会返回pair，表示是否成功

// erase返回下一个元素的迭代器
set.erase(pos);
set.erase(beg, end);
set.erase(elem);
set.clear();
```

### 查找和统计

```cpp
set.find(key);  // 如果key存在，则返回迭代器，如果不存在，则返回set.end()
set.count(key); // 统计key的个数，对于set，要么是0要么是1
```

### set和multiset

`multiset.insert()`时不会返回`pair`，只返回迭代器

```cpp
pair<set<int>::iterator, bool> ret = set.insert(1);
if (ret.second)
	cout << "插入成功";
```

### 自定义排序规则

使用仿函数

```cpp
class compare {
	public:
		bool operator()(int a, int b) const {
			return a > b;
		}
};

set<int, compare> st;  // st会从小到大排序
```


## pair

不需要包含头文件
成对出现的数据
```cpp
pair<T, T> p(value1, value2);
pair<T, T> p = make_pair(value1, value2);
p.first;  p.second;  // 访问
```


## map

`map` 中每个元素都是 `pair` 类型的 `(key, value)`
`key`值不允许重复

### 构造和赋值

```cpp
map<T1, T2> mp;
map<T1, T2> mp1(mp);
mp.insert(pair<char, int>('a', 2))
mp1 = mp;
```

### 大小和交换

同 set

### 插入删除

同 set

```cpp
mp.insert(pair<T1, T2>(a, b));
mp.insert(make_pair(a, b));
mp.insert(map<T1, T2>::value_type(a, b));

mp['c'] = 2;  // 会首先查找有没有 'c' 键，如果没有会创建value=0的pair
```

### 查找统计

同 `set`

### 自定义排序规则

同 `set`


# STL 函数对象

重载了函数调用运算符的对象，也叫仿函数
特点：
- 可以传参，可以有返回值
- 因为调用后不会立即释放，所以可以记录状态

```cpp
class MyAdd {
	public:
		MyAdd() {
			count = 0;
		}
		int count;
		int operator()(int a, int b) {
			return a + b;
			count++;
		}

};

int main() {
	MyAdd add;
	add(1, 3);
	add(4, 4);
	cout << add.count << endl;  // 2
}
```

## 谓词

返回bool类型的仿函数
如果operator()接受1个参数：一元谓词；2个参数：二元谓词
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Pred {
	public:
		bool operator()(int a) {
			return a > 5;
		}
};

int main() {
	vector<int> v;
	for (int i; i < 10; i++)
		v.push_back(i);
	vector<int>::iterator it = find_if(v.begin(), v.end(), Pred());  // 条件查找
	if (it == v.end())
		cout << "v中无大于5的项";
	else
		cout << *it;
}
```


## 内建函数对象

要包含头文件 `#include<functional>`

### 算术仿函数

```cpp
negate<int> n; // 取反仿函数
cout << n(50) <<endl;  // -50

plus<int> p;  // 相加仿函数
cout << p(13, 23) << endl; // 36
```

### 关系仿函数

```cpp
equal_to<T>;
not_equal_to<T>;
greater<T>;
greater_equal<T>;
less<T>;
less_equal<T>;

// 例子
sort(v.begin(), v.end(), greater_equal<int>());
```

### 逻辑仿函数

```cpp
logical_and<T>
logical_or<T>
logical_not<T>
```

# STL 常用算法

头文件：
`algorithm`：最大
`numeric`：体积小，只包含了一些数学运算的模板函数
`functional`：模板类，函数对象

### 遍历

`for_each(beg, end, _func)`
- `_func`：可以是普通函数也可以是仿函数


`transform(beg1, end1, beg2, _func)`
- 把 `(beg1, end1)`范围内的数据，用`_func`处理后搬运到`beg2`处
- 注意： 搬运前要开辟目标容器的空间（`resize()`）

## 查找

`find(beg, end, val)`
- 查找自定义数据类型时，一般要先重载 `==` 运算符
- 返回迭代器

`find_if(beg, end, _Pred)`
- `_Pred`：函数或谓词

`adjacent_find(beg, end)`
- 查找相邻重复元素，返回第一个元素的迭代器，如果没有重复元素，返回`end`

`binary_search(beg, end, value)`
- 查找指定元素在有序容器是否出现，返回`true` / `false`
- 无序序列不可用

## 统计

`count(beg, end, value)`
- 统计自定义数据类型时，一般要先重载 `==` 运算符

`count_if(beg, end, _Pred)`


## 排序

`sort(beg, end [, _Pred])`

`random_shuffle(beg, end)`
- 根据种子，把元素打乱

```cpp
#include<ctime>
#include<algorithm>
srand((unsigned int)time(NULL));
random_shuffle(v.begin(), v.end());
```

`merge(begin1, end1, beg2, end2, dest)`
- `dest`：目标容器的起始迭代器
- 将两个有序容器合并，存储到另一个容器中，仍然有序，但是两个容器的排序规则必须一样

`reverse(beg, end)`
- 反转

## 拷贝和替换算法

`copy(beg, end, dest)`
- 把指定位置的元素拷贝到目标容器
- `dest`：目标容器的起始位置

`replace(beg, end, oldvalue, newvalue)`
- 把指定位置的旧元素替换为新元素

`replace_if(beg, end, _Pred, newvalue)`
- 条件替换

`swap(c1, c2)`
- 直接传入容器，类型要一致

## 算术生成算法

要包含头文件`<numeric>`

`accumulate(beg, end, value)`
- 返回区间累加的结果
- `value`是起始值，一般传入 0

`fill(beg, end, value)`
- 向指定位置填入`value`

## 常用的集合算法

`set_intersection(beg1, end1, beg2, end2, dest)`
- 求两个有序序列的交集
- 返回`dest`对应的交集结束迭代器

`set_union(beg1, end1, beg2, end2, dest)`
- 求两个有序序列的并集
- 返回迭代器

`set_difference(beg1, end1, beg2, end2, dest)`
- 求两个有序序列的差集（c1 - c2）
- 返回迭代器