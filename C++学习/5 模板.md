另一种编程思想：泛型编程
模板分为 函数模板 类模板
语法： 
`template<typename T>`
`template <typename T, int N>`
`template <typename T1, typename T2>`
	T 为类型名，可以替换

# 函数模板

```cpp
#include<iostream>
using namespace std;

template<typename T>
void swapab(T &a, T &b) {
	T temp = a;
	a = b;
	b = temp;
}

int main(){
	int a=1, b=2;
	// 自动类型推导
	swapab(a, b);
	// 显式指定类型
	swapab<int>(a, b);
	
	cout << a << ' ' << b;
}
```

**注意**：
模板必须确定类型才能使用，即便函数中没有用到 T
模板自动推导类型时，不存在隐式类型转换
显式指定类型后，函数模板类似于普通函数，可以发生隐式转换
函数模板可以重载

**调用规则**：
优先调用普通函数，但是如果模板产生更好的匹配（如调用普通函数时需要隐式转换），则优先调用模板
通过空模板的参数列表，即`<>`，可以强制调用模板

# 类模板

和函数模板类似

```cpp
template<typename NameType = string, typename AgeType = int>
class Person {
	public:
		NameType name;
		AgeType age;
		
		Person(NameType name, AgeType age) {
			this->name = name;
			this->age = age;
		}

		void showIFO() {
			cout << name << ' ' << age;
		}
};

int main(){
	Person<string, int> dog("狗子", 15);
	dog.showIFO();
}
```
- 类模板在C++之前不支持自动类型推导，之后支持，所以可以这样写：
	`Person dog("狗子", 15);`
- 类模板支持默认参数
- 类模板中的成员函数在调用时才会创建，和普通类不一样，因为只有在调用时才知道T是什么类型
## 类模板的三种传参方式

1. 直接指定类型
2. 类型模板化
3. 类模板化
```cpp
void printInfo(Person<string, int> &p) {}

template<class T1, class T2>
void printInfo(Person<T1, T2> &p) {}

template<class T>
void printInfo(T &p) {}
```

## 类模板的继承

- 子类继承带有模板的父类时，需要指定类型，否则，编译器无法为其分配内存
- 可以把子类也变为模板，这样可以灵活地继承

```cpp
#include<iostream>
#include<string>
using namespace std;

template<class T>
class Base {
	public:
		T Bname;
};

// 继承方法一
class Son1: public Base<char> {
	public:
		Son1() {
			cout << typeid(Bname).name() << endl;
		}
};

// 继承方法二
template<class T1, class T2>
class Son2: public Base<T1> {
	public:
		T2 Sname;
		Son2() {
			cout << typeid(this->Bname).name() << endl;
			cout << typeid(Sname).name() << endl;
		}
};

int main(){
	Son1 son1;
	Son2<int, char> son2;
}

/*
输出: 
c
i
c
*/
```

## 类内函数的类外实现

```cpp
template<class T1, class T2>
class Base {
	public:
		Base(T1, T2);
		void fuc1(T1, T2);
};

template<class T1, class T2>
Base<T1, T2>::Base(T1 a, T2 b) { ... }

template<class T1, class T2>
void Base<T1, T2>::fuc(T1 a, T2 b) { ... }
```

## 类模板分文件编写

类模板中的成员在调用时创建，导致链接多文件时无法识别到函数实现

解决方法：
- 直接包含.cpp文件（不推荐）
- 将声明和实现写在同一个文件中，后缀名改为.hpp

## 类模板的友元函数

建议直接在类中定义友元函数的实现

## 实例（自定义列表）
```cpp
#include <iostream>
using namespace std;

template <typename ElemType>
class MyArray {
	public:
		MyArray(int capacity) {
			this->pArray = new ElemType[capacity];
			this->capacity = capacity;
		}
		~MyArray() {
			if (this->pArray != nullptr) {
				delete[] this->pArray;
			}
			this->pArray = nullptr;
		}

		// 拷贝构造函数
		MyArray(const MyArray &ori) {
			this->capacity = ori.capacity;
			this->size = ori.size;
			this->pArray = new ElemType[ori.capacity];
			for (int i = 0; i < this->size; i++) {
				this->pArray[i] = ori.pArray[i];
			}
		}
		
		// =运算符重载为深拷贝版本
		MyArray& operator=(const MyArray &ori) {
			if (this->pArray) {
				delete[] this->pArray;
			}
			this->capacity = ori.capacity;
			this->size = ori.size;
			this->pArray = new ElemType[ori.capacity];
			for (int i = 0; i < this->size; i++) {
				this->pArray[i] = ori.pArray[i];
			}
			return *this;
		}
		// []运算符重载
		ElemType& operator[](int i) {
			if (i < 0 || i > this->size - 1) {
				exit(-1);
			}
			return this->pArray[i];
		}

		// 尾插
		void pushBack(const ElemType &e) {
			if (this->size == this->capacity) {
				return;
			}
			else {
				this->pArray[this->size++] = e;
			}
		}

		// 尾删
		void popBack() {
			if (this->size > 0) {
				this->size--;
			}
		}

		// 遍历
		void tranverse() {
			for (int i = 0; i < size; i++) {
				cout << pArray[i] << ' ';
			}
			cout << endl;
		}
	private:

		// 指向堆区开辟的区域
		ElemType *pArray;

		int capacity;
		int size;
};

int main() {

	MyArray<int> array1(5);
	for (int i=0; i<5; i++) {
		array1.pushBack(i);
	}
	array1.tranverse();
	
	array1[1] = 10;
	cout << array1[2] << endl;

	// cout << array1[5];
	array1.tranverse();
}
```

# STL

广义上分为**容器**、**算法**、**迭代器**
容器和算法之间通过迭代器衔接

细分分为：**容器**、**算法**、**迭代器**、**仿函数**、**适配器（配接器）**、**空间配置器**

**容器**
存放数据
	**序列式容器**：有顺序
	**关联式容器**：无序，二叉树结构

**算法**
	**质变算法**：会改变数据
	**非质变算法**：不改变数据

**迭代器**
提供一种能够依次访问容器内元素数据 而不外露该容器的内部表示形式
每个容器都有专属迭代器
其类似指针

## vector

容器：`vector`
算法：`for_each`
迭代器：`vector<T>::iterator`

动态扩展机制：不是在原空间扩展，而是找更大的空间，释放原空间

```cpp
vector<int> v;
v.push_back(5);

vector<int>::iterator itBegin = v.begin();  // 指向首元素
vector<int>::iterator itEnd = v.end();      // 指向最后一个元素的后一位

// 遍历方式一
while (itBegin != itEnd) {
	cout << *itBegin << endl;
	itBegin++;
}

// 遍历方式二
for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
	cout << *it << endl;
}

// 遍历方式三
void print(int val) {
	cout << val << endl;
}
for_each(v.begin(), v.end(), print);

// 嵌套容器的遍历
for (vector<vector<int>>::iterator itb = vb.begin(); it != vb.end(); it++) {
	for (vector<int>::iterator its = (*itb).begin(); its != (*itb).end(); its++) {
		cout << *its << ' ';
	}
	cout << endl;
}
```

#### 构造函数

```cpp
vector<T> v1;
vector<T> v2(v1.begin(), v1.end())  // 区间内数据拷贝到v2构造
vector<T> v3(int n, T data)
vector<T> v4(v3)  // 拷贝构造
```

#### 赋值

可以使用 = 也可以 assign
```cpp
v.assign(v1.begin(), v1.end);
v.assign(int n, T data);
```

#### 容量和大小

```cpp
v.empty()  // 返回布尔值
v.capacity()
v.size()
v.resize(int n [, T data])  // 调整大小，若变大，用传入数据填补
```

#### 插入和删除

```cpp
v.push_back(T data);
v.pop_back();   // 注意它不返回pop出来的值
v.insert(const_iterator pos [, int n], T elem);  // 必须是迭代器类型
v.erase(const_iterator pos);
v.erase(const_iterator start, const_iterator end);
v.clear();
// 示例：
v.insert(v.begin() + 1, 2);
v.insert(v.begin(),5 , 3);
```

#### 数据存取

可以使用 `at` 和 `[]`，根据索引获取元素
也可以使用`v.front()   v.back()` 获取首/尾元素

#### 交换vector

`v1.swap(v2)` 可以交换v1和v2的数据
可以用`vector<T>(v).swap(v)`压缩`v`容器的空间(capacity)

#### 预留空间

使用 `v.reserve(int n)`预留n个数据的空间，减少内存开辟的次数

## string

### 构造函数

```cpp
string()  // 空的字符串
string(const char *s) // 字符串构造
string(const string &str)  // 拷贝构造
string(int n, char c)  // 初始化为n个字符c 
```
### 赋值操作

- 使用 `=` 通过 `string`类、字符串、字符赋值
- 使用 `assign` 成员函数
```cpp
string s1;
s1.assign(const string &s);
s1.assign(const char *s [, int n]);  // 把字符串[的前n个字符]赋值给s
s1.assign(int n, char c);
```

### 字符串拼接

- 可以使用 +、+=
- 也可以使用`append`
```cpp
s1.append(const char *s [, int n])
s1.append(const string &s [, int pos [, int n]]);  // 从索引为pos的字符开始拼接n个字符
// 如果不指定n，则拼接到s的末尾
```

### 查找和替换

```cpp
s1.find(字符串或字符 [, int pos [, int n]])  // 从pos开始，查找传入字符类型的前n个字符首次出现的位置，若失败，则返回 -1
s1.rfind(字符串或字符 [, int pos [, int n]])
s1.replace(int pos, int n, 字符串或字符)  // 从pos开始的n个字符替换为传入字符类型
```

### 比较

```cpp
s1.compare(字符类型)
```
按照 ASCII码 比较
< : 负数
\> : 正数
\= : 0

### 字符存取

使用下面的语法获取某个位置的字符
```cpp
s[i];
s.at(i);
```

可以直接使用 `=` 对字符进行修改

### 插入和删除

```cpp
s.insert(int pos, 字符类型);
s.insert(int pos, int n, char c); //在pos处（前）插入n个c
s.erease(int pos, int n = npos)  // 删除pos开始n个字符
```

### 获取子串

```cpp
s.substr(int pos = 0, int n = npos);  // 返回从 pos 开始的 n 个字符构成的字符串
```


## deque

双向队列
相对于deque，vector 对头的处理效率低，但是访问快
![[Pasted image 20260106091806.png]]

### 构造函数

同 `vector`

补充 `const_iterator`的用法
```cpp
void printDeque(const deque<int> &q) {
	for (deque<int>::const_iterator it = q.begin(); it != q.end(); it++) {
		cout << *it;
	}
}
```

### 赋值

同 `vector`

### 大小

`deque`中无容量（`capacity`）属性
其它同 `vector`

### 插入和删除

多了`q.push_front()`、`q.pop_front()`
其它同 `vector`

### 数据存取

同 `vector`

### 排序

`sort(iterator beg, iterator end)`

```cpp
#include <iostream>
#include <deque>
#include <algorithm>

using namespace std;

void printDeque(deque<int> &q) {
    for (int i = 0; i < q.size(); i++) {
        cout << q[i] << " ";
    }
    cout << endl;
}

int main() {
	deque<int> q;
    q.push_back(1);
    q.push_back(2);
    q.push_front(3);
    q.push_front(4);
	printDeque(q);
	sort(q.begin(), q.end());
	printDeque(q);
}
```