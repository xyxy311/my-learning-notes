
# 初步
## 一些解释
![[Pasted image 20260111155839.png]]

## 按钮

```cpp
/* ============== mainwindow.cpp ============== */

#include "mainwindow.h"
#include <QPushButton>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    // 创建一个按钮
    QPushButton *btn = new QPushButton;
    // btn->show();   // 以顶层方式弹出窗口按钮
    btn->setParent(this);  // 依赖窗口的按钮
    btn->setText("第一个按钮");  // 设置文本

    // 创建第二个按钮
    QPushButton *btn2 = new QPushButton("第二个按钮", this);

    // 移动按钮位置
    btn->move(150, 50);
    btn->resize(100, 40);

    // 重置窗口大小
    resize(800, 600);

    // 设置固定大小
    setFixedSize(400, 300);

    // 设置标题
    setWindowTitle("主窗口");
}

MainWindow::~MainWindow() {}

```

## 对象树

在堆区创建对象时，其构造函数接受一个指针作为父对象指针，其父对象会把新对象加入`children`表中
如果父类是`QObject`或其子类派生的类，不用内存管理，父类析构时，子对象也会析构

# 信号和槽

```cpp
connect(
    发送者对象指针,   // 谁触发事件？
    &发送者类名::信号名,  // 触发的是什么事件？（信号）
    接收者对象指针,   // 谁处理这个事件？
    &接收者类名::槽函数名  // 处理事件的动作？（槽函数）
);
```
信号槽的有点：松散（发送端和接收端本身无关联）耦合（`connect`将两端连接在一起）

```cpp
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    // 创建第二个按钮
    QPushButton *btn2 = new QPushButton("关闭窗口", this);

    // 点击按钮则关闭窗口
        // connect(对象地址, 函数地址, 对象地址, 函数地址)
    connect(btn2, &QPushButton::clicked, this, &MainWindow::close);
}
```

## 自定义信号和槽

**信号**
- 写在`signal`下
- 返回值是`void`，只需要声明，不需要实现
- 可以有参数，可以重载
- 使用`emit`触发

**槽**
- 早期写在`public slots`下，高版本任意
- 返回值是`void`，需要声明和实现
- 可以有参数，可以重载

**发生重载时**，要传入函数指针
信号可以和信号连接
可以使用`disconnect()`断开连接

```cpp
#include "mainwindow.h"
#include <QPushButton>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    t = new Teacher;
    s = new Student;

    QPushButton *btn = new QPushButton("下课", this);
    this->resize(600, 400);
    btn->resize(100, 60);
    btn->move(250, 170);
    btn->show();

    connect(btn, &QPushButton::clicked, this, &MainWindow::classOver);

    // 无重载直接传入
    // connect(t, &Teacher::hungery, s, &Student::treat);

    // 有重载要先用函数指针指定使用哪一个版本
    void (Teacher::*teacher_hungery)(QString) = &Teacher::hungry;
    void (Student::*student_treat)(QString) = &Student::treat;

    connect(t, teacher_hungery, s, student_treat);
    disconnect(t, teacher_hungery, s, student_treat);

    // classOver();
}

MainWindow::~MainWindow() {}

void MainWindow::classOver()
{
    emit t->hungry("宫保鸡丁");
}
```