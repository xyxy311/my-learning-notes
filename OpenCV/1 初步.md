# Mat对象
![[Pasted image 20251210142054.png]]
	Mat类核心定位
		历史背景：替代C接口IplImage（手动内存管理），OpenCV 2.0引入C++接口
		核心优势：自动内存管理、支持多维度矩阵（图像+通用运算）
	Mat内部结构与内存管理
		组成部分
			矩阵头（Header）：固定大小，存元数据（大小、类型、地址、引用计数）
			像素数据指针：指向实际像素内存，占比远大于矩阵头
		引用计数机制
			浅拷贝：赋值/复制构造仅复制头部，共享数据（例：Mat B(A)、C=A）
			深拷贝：显式调用clone()/copyTo()，复制完整数据（例：Mat F=A.clone()）
			内存释放：计数降为0时自动释放数据区
	图像存储方式
		颜色空间（像素分量组合）
			RGB/BGR：OpenCV默认BGR（红蓝互换），通用显示
			HSV/HLS：分色相/饱和度/亮度，光照不敏感场景
			YCrCb：JPEG格式专用，分离亮度与色度
			CIE Lab*：感知均匀，适合色差计算
		数据类型（存储精度）
			格式：CV_[位数][符号][类型前缀]C[通道数]
			示例：CV_8UC3（8位无符号字符，3通道）、CV_32FC1（32位浮点，1通道）
			影响：位数越高，精度/内存占用越高
	显式创建Mat对象的方式
		构造函数：Mat M(2,2,CV_8UC3,Scalar(0,0,255))
		C/C++数组初始化：int sz[3]={2,2,2}; Mat L(3,sz,CV_8UC(1),Scalar::all(0))
		create()函数：M.create(4,4,CV_8UC(2))（仅分配内存，不初始化值）
		MATLAB风格：Mat::zeros()/ones()/eye()（例：Mat E=Mat::eye(4,4,CV_64F)）
		逗号分隔/初始化列表：Mat C=(Mat_(3,3)<<0,-1,0,-1,5,-1,0,-1,0)
		现有对象新头+克隆：Mat RowClone=C.row(1).clone()
		随机值填充：randu(R, Scalar::all(0), Scalar::all(255))
	输出格式化与扩展输出
		矩阵输出格式
			默认：cout << R
			其他：Python（FMT_PYTHON）、CSV、NumPy、C格式（format()函数）
		扩展数据类型输出
			点：Point2f（二维）、Point3f（三维）
			向量：vector（转Mat后输出）、vector（直接输出）

# IO操作

```python
import cv2 as cv

img = cv.imread("image\\kids.jpg")              # 读

if img is None:
    print("错误：无法加载图像，请检查路径是否正确。")
    exit()

	cv.imshow('img', img)                       # 展示

k = cv.waitKey(0)

if k == ord('s'):
    out_put_path = 'images/saved_kids.jpg'
    cv.imwrite(out_put_path, img)               # 写
    print("图像已保存")
else:
    print("图像未保存")

cv.destroyAllWindows()
```
图像数组shape = (h, w, 通道数)

`imread(路径,模式)`  
- 1：`cv.IMREAD_COLOR`：以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。
- 0：`cv.IMREAD_GRAYSCALE`：以灰度模式加载图像
- -1：`cv.IMREAD_UNCHANGED`：包括alpha通道的加载图像模式。

# 颜色空间

HSV颜色空间
- H：色调
- S：饱和度，↓掺白色
- V：明度，↓掺黑色
## 拆分

- 通道拆分
`b,g,r = cv.split(img)`  

- 通道合并
`img = cv.merge((b,g,r))`

## 转换

`cv.cvtColor(input_image，flag)`  

- input_image: 进行颜色空间转换的图像
- flag: 转换类型  
    cv.COLOR_BGR2GRAY : BGR↔Gray  
    cv.COLOR_BGR2HSV: BGR↔HSV

 ```python
 import cv2 as cv

img = cv.imread("./image/star.jpeg")

hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)

h, s, v = cv.split(hsv)

hsv1 = cv.merge([h, s, v])
img1 = cv.cvtColor(hsv1, cv.COLOR_HSV2BGR)

cv.imshow('img', img)
cv.imshow('img-1', img1)

cv.waitKey(0)
cv.destroyAllWindows()
 ```
 
## 阈值

`mask = cv2.inRange(src, lowerb, upperb)`
- `src`：输入图像
- `lowerb upperb`：长度与图像通道数相同的数组，框定范围
- `mask`：输出的掩码（单通道二值图，`uint8` 类型，符合范围的像素为 255，否则0）
eg：
```python
frame_threshold = cv.inRange(frame_HSV, (low_H, low_S, low_V), (high_H, high_S, high_V))
res = cv.bitwise_and(frame_HSV, frame_HSV, mask = frame_threshold)
cv.imshow('res',res)
```
可提取 `frame_HSV` 中 `mask` 标记的区域（感兴趣区域），其他区域变黑


# 图像的基本操作

## 获取ROI

语法：`image[y1:y2, x1:x2]`

```python
# 修改 ROI  
roi[:, :] = [0, 255, 0]  # 将 ROI 区域设置为绿色  
# 将修改后的 ROI 放回原图像  
img[0:100, 0:100] = roi
```

## 补充-插值方法

- `INTER_NEAREST`：速度最快，但边缘有明显锯齿，像素感强；
- `INTER_LINEAR`：边缘较平滑，细节中等；
- `INTER_CUBIC`：边缘更细腻，细节保留更好，但计算时间是`INTER_NEAREST`的 5-10 倍；
- `INTER_LANCZOS4`：细节最锐利，但速度最慢（是`INTER_CUBIC`的 2-3 倍）。

## 补充-创建滑动条

```python
cv.createTrackbar(
    trackbarName,  # 滑动条名称（唯一标识）
    windowName,    # 绑定的窗口名称（滑动条显示在该窗口上）
    value,         # 滑动条初始值
    count,         # 滑动条最大值（最小值固定为0）
    onChange       # 滑动条值变化时的回调函数（可选，None则无回调）
)

# 与之配套
current_value = cv.getTrackbarPos(trackbarName, windowName)
```

模板：设置窗口，滑动条信息(name，min，max)，创建滑动条，主循环中实时获取变量值
```python
import cv2 as cv
import numpy as np

# ===================== 滑动条极简模板（核心部分） =====================
# 1. 初始化：创建窗口（滑动条必须绑定窗口）
WINDOW_NAME = "Trackbar_Template"
cv.namedWindow(WINDOW_NAME, cv.WINDOW_NORMAL)  # 窗口可缩放

# 2. 定义滑动条（按需增删，格式：(名称, 初始值, 最大值)）
TRACKBARS = [
    ("param1", 50, 100),   # 示例参数1：范围0~100，初始50
    ("param2", 3, 15)      # 示例参数2：范围0~15，初始3
]

# 3. 批量创建滑动条（无回调，仅占位）
for tb_name, init_val, max_val in TRACKBARS:
    cv.createTrackbar(tb_name, WINDOW_NAME, init_val, max_val, lambda x: None)

# 4. 核心循环：实时读取滑动条值 + 业务处理
while True:
    # ---------------- 【核心】读取所有滑动条值 ----------------
    tb_vals = {}  # 存储{滑动条名: 当前值}
    for tb_name, _, _ in TRACKBARS:
        tb_vals[tb_name] = cv.getTrackbarPos(tb_name, WINDOW_NAME)
    
    # ---------------- 【自定义】你的业务逻辑（替换这里） ----------------
    # 示例：打印参数 + 生成测试图像（替换为你的处理逻辑）
    img = np.zeros((300, 500, 3), np.uint8)  # 黑色背景图
    y = 50
    for name, val in tb_vals.items():
        cv.putText(img, f"{name}: {val}", (50, y), 
                   cv.FONT_HERSHEY_SIMPLEX, 1, (0,255,0), 2)
        y += 50
    
    # ---------------- 显示 + 退出逻辑 ----------------
    cv.imshow(WINDOW_NAME, img)
    if cv.waitKey(1) & 0xFF == ord('q'):
        break

# 5. 资源释放
cv.destroyAllWindows()
```
## 变换

### 缩放

`dst = cv.resize(src, dsize, fx, fy, interpolation)`
- `dsize`：像素大小
- `fx、fy`：缩放因子
- `interpolation`：差值方法

```python
import cv2 as cv
img = cv.imread("image/cat.jpeg")

roi = img[:342, 320:600]
# 两种缩放方法，注意第二种要指定 None
roi_small = cv.resize(roi, (150, 100), interpolation=cv.INTER_LINEAR)
roi_large = cv.resize(roi, None, fx=1.5, fy=2, interpolation=cv.INTER_LINEAR)

cv.imshow("cat", img)
cv.imshow("roi", roi)
cv.imshow("roi_small", roi_small)
cv.imshow("roi_large", roi_large)

cv.waitKey(0)
cv.destroyAllWindows()
```
### 平移

通过矩阵`M = [[1 0 x], [0 1 y]]` 实现，必须是 `float` 类型（通常是 `np.float32`）
`dst = cv.warpAffine(src, M, dsize)`
- `M` 必须是 `float` 类型（通常是 `np.float32`）
- `dsize = (宽度, 高度)`

```python
import cv2 as cv
import numpy as np

img = cv.imread("image/deer.jpeg")

rows, cols, _ = img.shape   # 注意r和c的顺序
M = np.float32([[1, 0, 100],[0, 1, 50]])  # 学会这样创建矩阵
img1 = cv.warpAffine(img, M, (cols, rows))  # 注意r和c的顺序

cv.imshow("loog neck deer", img1)
cv.waitKey(0)
cv.destroyAllWindows()
```

### 旋转

使用`M = cv.getRotationMatrix2D(center, angle, scale)`获得旋转矩阵
- `scale`: 各向同性比例因子，一般用 1

```python
img = cv.imread("image/deer.jpeg")
h, w = img.shape[:2]
center = (w // 2, h // 2)
M = cv.getRotationMatrix2D(center, 90, 1)
img1 = cv.warpAffine(img, M, (h, w))    
```
### 翻转

`dst = cv.flip(src, int)`
- `int`为 0 时，垂直翻转，非0，水平翻转
```python
img1 = cv.flip(img, 0)  # 垂直翻转
flipped_img = cv2.flip(img, 1)  # 水平翻转
```

### 重映射

`dst = remap(src, map1, map2, interpolation)`

```python
# 和原图像相同
map_x = np.zeros((h,w), dtype=np.float32)
map_y = np.zeros((h,w), dtype=np.float32)
for x in range(w):
    map_x[:, x] = x
for rows in range(h):
    map_y[rows, :] = rows

img1 = cv.remap(img, map_x, map_y, cv.INTER_LINEAR)

# 水平翻转
for x in range(w):
    map_x[:, x] = w - 1 - x
for rows in range(h):
    map_y[rows, :] = rows
    
# 缩小为原来的1/2
for y in range(h):
    for x in range(w):
        map_x[y, x] = 2*x
        map_y[y, x] = 2*y
```

### 仿射变换

给定三个点的原坐标 `pts1` 和变换后的坐标 `pts2` ，使用
`M = cv.getAffineTransform(pts1, pts2)`获得矩阵

```python
import cv2 as cv
import numpy as np

img = cv.imread("image/deer.jpeg")
h, w, _ = img.shape

pts1 = np.float32([[0,0],[1,0],[0,1]])
pts2 = np.float32([[0,0],[0.5,0.25],[0.25,0.5]])
M = cv.getAffineTransform(pts1, pts2)
img1 = cv.warpAffine(img, M, (int(0.5*w+0.25*h), int(0.5*h+0.25*w)))

cv.imshow("loog neck deer", img)
cv.imshow("loog neck deer1", img1)
cv.waitKey(0)
cv.destroyAllWindows()
```
使原图变成菱形，图片大小刚好能显示全
### 透视变换

需要给出图像上的 4 个点和输出图像上的对应点`pts1 pts2`
通过函数 `cv.getPerspectiveTransform(pts1,pts2)` 找到变换矩阵
```python
pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]])
pts2 = np.float32([[0,0],[300,0],[0,300],[300,300]])
 
M = cv.getPerspectiveTransform(pts1,pts2)
 
dst = cv.warpPerspective(img,M,(300,300))
```

	# 阈值处理

通过设定一个阈值，可以将图像中的像素分为两类：高于阈值的像素和低于阈值的像素，用于将图像转换为二值图像（即黑白图像）。
## 简单阈值处理
`retval, dst = cv2.threshold(src, thresh, maxval, type)`
- `src`: 是灰度图
- `thresh`: 设置的阈值
- `maxval`: 达到条件赋予的新值
- `retval`: 实际使用的`type`
- `type`：阈值处理的类型
	- `cv2.THRESH_BINARY`: 如果像素值大于阈值，则赋予 `maxval`，否则赋予 `0`。
	- `cv2.THRESH_BINARY_INV`: 与 `cv2.THRESH_BINARY` 相反，如果像素值大于阈值，则赋予 `0`，否则赋予 `maxval`。
	- `cv2.THRESH_TRUNC`: 如果像素值大于阈值，则赋予阈值，否则保持不变。
	- `cv2.THRESH_TOZERO`: 如果像素值大于阈值，则保持不变，否则赋予 `0`。
	- `cv2.THRESH_TOZERO_INV`: 与 `cv2.THRESH_TOZERO` 相反，如果像素值大于阈值，则赋予 `0`，否则保持不变。

```python
import cv2 as cv
import matplotlib.pyplot as plt

img = cv.imread("image/gradient.jpg", cv.IMREAD_GRAYSCALE)  # 读取灰度图
ret, thresh1 = cv.threshold(img, 127, 255, cv.THRESH_BINARY)
ret, thresh2 = cv.threshold(img,127,255,cv.THRESH_BINARY_INV)
ret, thresh3 = cv.threshold(img,127,255,cv.THRESH_TRUNC)
ret, thresh4 = cv.threshold(img,127,255,cv.THRESH_TOZERO)
ret, thresh5 = cv.threshold(img,127,255,cv.THRESH_TOZERO_INV)

titles = ['origin','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV']
images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]

for i in range(6):
    plt.subplot(2, 3, i + 1)        # 多图绘制
    plt.imshow(images[i], 'gray')
    plt.title(titles[i])
    plt.xticks([]), plt.yticks([])  # 隐藏坐标
plt.show()
```
注意 255 表示 白色，0 表示 黑色
![[Pasted image 20251213143531.png]]

## 自适应阈值处理

应对光照变化的情况，为图像的不同区域确定一个阈值

`dst = cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)`
- `src`: 输入图像，通常为灰度图像。
- `adaptiveMethod`: 自适应阈值计算方法，常见的类型有：
    - `cv2.ADAPTIVE_THRESH_MEAN_C`: 阈值是邻域的平均值减去常数 `C`。
    - `cv2.ADAPTIVE_THRESH_GAUSSIAN_C`: 阈值是邻域值的高斯加权和减去常数`C`
- `thresholdType`: 通常为 `cv2.THRESH_BINARY` 或 `cv2.THRESH_BINARY_INV`。
- `blockSize`: 计算阈值时使用的邻域大小，必须为奇数。
- `C`: 从平均值或加权平均值中减去的常数。`C`大 -> 达到阈值的多 -> 更亮（如果不是`_INV`）

## Otsu's 二值化
适用于双峰图，可以自动确定阈值
`retval, dst = cv2.threshold(src, thresh, maxval, type)`
- `src`: 输入图像，通常为灰度图像。
- `thresh`: 由于 Otsu's 方法会自动确定阈值，因此该参数通常设置为 `0`。
- `type`: 阈值处理的类型，通常为 `cv2.THRESH_BINARY` 或 `cv2.THRESH_BINARY_INV`，并加上 `cv2.THRESH_OTSU`。

```python
import cv2 as cv
from matplotlib import pyplot as plt
 
img = cv.imread('image\dilireba.png', cv.IMREAD_GRAYSCALE)
ret, img1 = cv.threshold(img, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU)
img2 = cv.adaptiveThreshold(img, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, 
                            cv.THRESH_BINARY, 11, 5)
img3 = cv.adaptiveThreshold(img, 255, cv.ADAPTIVE_THRESH_MEAN_C, 
                            cv.THRESH_BINARY, 11, 5)

plt.subplot(2, 2, 1)
plt.imshow(img, 'grey')
plt.title("origin")

plt.subplot(2, 2, 2)
plt.imshow(img1, 'grey')
plt.title("threshold1")

plt.subplot(2, 2, 3)
plt.imshow(img2, 'grey')
plt.title("threshold2")

plt.subplot(2, 2, 4)
plt.imshow(img3, 'grey')
plt.title("threshold3")

plt.show()
```
![[Pasted image 20251213151848.png]]


# 形态学操作

## 内核（结构元素）

类似于有形状的印章，每次处理二值一小个区域，在图像上滑动
可使用`kernel = cv.getStructuringElement(shape, size)`获取
```python
# 矩形内核
kernel = cv.getStructuringElement(cv.MORPH_RECT,(5,5))

# 椭圆内核
kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE,(5,5))

# 十字形内核
kernel = cv.getStructuringElement(cv.MORPH_CROSS,(5,5))

# 菱形内核
kernel = cv.getStructuringElement(cv.MORPH_DIAMOND,(5,5))
```
小内核适用于 细节多、噪点小 的场景

## 腐蚀

`dst = cv2.erode(src, kernel, iterations=1)`
- `iterations`: 腐蚀操作的次数，默认为1。
## 膨胀

`dst = cv2.dilate(src, kernel, iterations=1)`

## 开闭运算

`dst = cv2.morphologyEx(src, op, kernel)`
- `op`: 形态学操作类型：
	- 开运算使用 `cv2.MORPH_OPEN`，先腐蚀后膨胀，去除小噪点、平滑物体边界。
	- 闭运算使用 `cv2.MORPH_CLOSE`，先膨胀后腐蚀，填充小孔洞、连接邻近物体。

```python
import cv2 as cv

img = cv.imread("image\letter.png")
kernel = cv.getStructuringElement(cv.MORPH_RECT, (3, 3))  # 使用函数创建内核

erode = cv.erode(img, kernel)   # 腐蚀
dilate = cv.dilate(img, kernel) # 膨胀

cv.imshow("origin", img)
cv.imshow("erode", erode)
cv.imshow("dilate", dilate)

cv.waitKey(0)
cv.destroyAllWindows()
```

![[Pasted image 20251214095511.png]]

```python
import cv2 as cv
import numpy as np

img1 = cv.imread("image\letterclose.png")
img2 = cv.imread("image\letteropen.png")

kernel = np.ones((10,10),np.uint8)  # 使用 Numpy 创建 kernel

close = cv.morphologyEx(img1, cv.MORPH_CLOSE, kernel) # 开闭运算
open = cv.morphologyEx(img2, cv.MORPH_OPEN, kernel)

cv.imshow("origin1", img1)
cv.imshow("close", close)
cv.imshow("origin2", img2)
cv.imshow("open", open)

cv.waitKey(0)
cv.destroyAllWindows()
```

![[Pasted image 20251214100334.png]]

# 图像滤波与降噪

平滑处理（也称为模糊处理），用于减少图像中的噪声或细节。

## 均值滤波

取平均值消除噪点

`cv2.blur(image, (5, 5))`
- `image`: 输入的图像。
- `(5, 5)`: 滤波核的大小，表示在水平和垂直方向上取平均值的范围。

**适用场景**
均值滤波适用于去除图像中的随机噪声，但可能会导致图像边缘变得模糊。

## 高斯滤波

计算像素加权平均值，在去除噪声的同时，能够更好地保留图像的边缘信息。

`cv2.GaussianBlur(image, (5, 5), 0)`
- `0`: 高斯核的标准差，如果为0，则根据核大小自动计算
	- sigma越大，高斯分布越 “平缓”，邻域像素权重差异越小（接近平均模糊）
	- 通常设为 1~5

## 中值滤波

一种非线性平滑处理方法。将图像中每个像素的值替换为其周围像素的中值。
中值滤波在去除椒盐噪声（即图像中随机出现的黑白点）时非常有效。

`cv2.medianBlur(image, 5)`
- `5`: 滤波核的大小，必须是奇数。一般 3~7

## 双边滤波

一种非线性的平滑处理方法，它结合了空间邻近度和像素值相似度。
双边滤波不仅考虑像素之间的空间距离，还考虑像素值之间的差异。与高斯滤波不同，双边滤波在平滑图像的同时，能够保留图像的边缘信息

 `cv2.bilateralFilter(image, 9, 75, 75)`
- `image`: 输入的图像。
- `9`: 滤波核的大小。通常 3~15
- `75`: 颜色空间的标准差，控制像素值相似度的权重。`sigmaColor` 越大，允许差异越大的像素参与模糊（边缘越容易被模糊） 通常 50~150
- `75`: 坐标空间的标准差，控制空间距离的权重。

先固定 d=9（中间值），再设 `sigmaColor`=75、`sigmaSpace`=75（基础值）；若噪点未消，增大 `sigmaColor/sigmaSpace` 到 100~125；若边缘变糊，减小 `sigmaColor` 到 50~60。

```python
import cv2 as cv

img = cv.imread("image\\dogGauss.jpeg", 0)
blur = cv.blur(img, (5, 5))
gaussianblur = cv.GaussianBlur(img, (5, 5), 0)
meidian = cv.medianBlur(img, 5)
bilateral = cv.bilateralFilter(img, 9, 75, 75)

cv.imshow("origin", img)
cv.imshow("blur", blur)
cv.imshow("gblur", gaussianblur)
cv.imshow("meidian", meidian)
cv.imshow("bilateral", bilateral)

cv.waitKey(0)
cv.destroyAllWindows()
```

# 视频

`cap = cv.VideoCapture(0)`
- 0 表示使用默认摄像头，1 2 3……可使用第一、二、三……摄像头
- 也可把 0 换成视频路径
使用`ret, frame = cap.read()`获取每一帧的图像，`ret`是一个布尔值，读到图像则返回`True`，读完/读错返回`False`
视频使用完后一定要`cap.release()`释放视频 / 摄像头资源

```python
import cv2 as cv
import time

cap = cv.VideoCapture(0)
while (True):

    # 读取每一帧
    ret, frame = cap.read()
    if ret:

        # 转化为灰度图并缩小
        if frame.ndim == 3:
            gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
        else:
            gray = frame
        small = cv.resize(gray, (120, 40))

        # 转化为字符形式
        lines = []
        for row in small:
	        # 注意 line 要转化成字符串形式
            line = ''.join(['#' if pixel > 127 else ' ' for pixel in row])
            lines.append(line)
        if lines:
            char = '\n'.join(lines)
        else:
            char = ''
        print('\033[H\033[J' + char)
        
        # 显示灰度图像
        cv.imshow('video', small)
        cv.waitKey(33)

    else:
        print('\033[H\033[J' + "结束了")
        break
cap.release()
cv.destroyAllWindows()
```

