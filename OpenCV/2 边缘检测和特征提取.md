
# å›¾åƒè¾¹ç¼˜æ£€æµ‹

## Canny

`edges = cv2.Canny(image, threshold1, threshold2, apertureSize=3, L2gradient=False)`

- `image`ï¼šè¾“å…¥å›¾åƒï¼Œå¿…é¡»æ˜¯å•é€šé“çš„ç°åº¦å›¾åƒã€‚
- `threshold1`ï¼šä½é˜ˆå€¼ï¼ˆæ¢¯åº¦å€¼ï¼‰
- `threshold2`ï¼šé«˜é˜ˆå€¼ï¼Œä¸¤ä¸ªé˜ˆå€¼æ¯”ä¾‹é€šå¸¸æ˜¯ 1ï¼š2æˆ–3 å¦‚ï¼ˆ100 200 æˆ– 50 150ï¼‰
- `apertureSize`ï¼šSobel ç®—å­çš„å­”å¾„å¤§å°ï¼Œé»˜è®¤ä¸º 3ï¼Œå¤§é€‚åˆå™ªç‚¹å¤šï¼Œä¸æ³¨æ„ç»†èŠ‚çš„ï¼Œå°é€‚åˆç²¾ç»†å›¾åƒ
- `L2gradient`ï¼šæ˜¯å¦ä½¿ç”¨ L2 èŒƒæ•°è®¡ç®—æ¢¯åº¦å¹…å€¼ï¼Œé»˜è®¤ä¸º Falseï¼ˆä½¿ç”¨ L1 èŒƒæ•°ï¼‰
- `edge`:  å•é€šé“äºŒå€¼å›¾åƒï¼Œè¾¹ç¼˜ä¸º 255ï¼ŒèƒŒæ™¯ä¸º 0

## Sobel

è®¡ç®—ä¸€é˜¶å¯¼ï¼ŒSobel ç®—å­æ˜¯ä¸€ç§åŸºäºæ¢¯åº¦çš„è¾¹ç¼˜æ£€æµ‹ç®—å­ï¼Œå®ƒé€šè¿‡è®¡ç®—å›¾åƒåœ¨æ°´å¹³å’Œå‚ç›´æ–¹å‘ä¸Šçš„æ¢¯åº¦æ¥æ£€æµ‹è¾¹ç¼˜ã€‚åˆäº†é«˜æ–¯å¹³æ»‘å’Œå¾®åˆ†æ“ä½œï¼Œå› æ­¤å¯¹å™ªå£°å…·æœ‰ä¸€å®šçš„æŠ‘åˆ¶ä½œç”¨ã€‚

`dst = cv2.Sobel(src, ddepth, dx, dy, ksize=3, scale=1, delta=0, borderType= cv2.BORDER_DEFAULT)`

- `src`ï¼šè¾“å…¥å›¾åƒã€‚
- `ddepth`ï¼šè¾“å‡ºå›¾åƒçš„æ·±åº¦ï¼Œé€šå¸¸ä½¿ç”¨Â `cv2.CV_64F`ã€‚
- `dx`ï¼šx æ–¹å‘ä¸Šçš„å¯¼æ•°é˜¶æ•°ã€‚
- `dy`ï¼šy æ–¹å‘ä¸Šçš„å¯¼æ•°é˜¶æ•°ã€‚
- `ksize`ï¼šSobel æ ¸çš„å¤§å°ï¼Œé»˜è®¤ä¸º 3ã€‚
- `scale`ï¼šç¼©æ”¾å› å­ï¼Œé»˜è®¤ä¸º 1ã€‚
- `delta`ï¼šå¯é€‰çš„ delta å€¼ï¼Œé»˜è®¤ä¸º 0ã€‚
- `borderType`ï¼šè¾¹ç•Œå¡«å……ç±»å‹ï¼Œé»˜è®¤ä¸ºÂ `cv2.BORDER_DEFAULT`ã€‚

## Laplacian

Laplacian ç®—å­æ˜¯ä¸€ç§äºŒé˜¶å¾®åˆ†ç®—å­ï¼Œå®ƒé€šè¿‡è®¡ç®—å›¾åƒçš„äºŒé˜¶å¯¼æ•°æ¥æ£€æµ‹è¾¹ç¼˜ã€‚å¯¹å™ªå£°æ¯”è¾ƒæ•æ„Ÿï¼Œå› æ­¤é€šå¸¸åœ¨ä½¿ç”¨ä¹‹å‰ä¼šå¯¹å›¾åƒè¿›è¡Œé«˜æ–¯å¹³æ»‘å¤„ç†ã€‚

`dst = cv2.Laplacian(src, ddepth, ksize=1, scale=1, delta=0, borderType= cv2.BORDER_DEFAULT)`

- `src`ï¼šè¾“å…¥å›¾åƒã€‚
- `ddepth`ï¼šè¾“å‡ºå›¾åƒçš„æ·±åº¦ï¼Œé€šå¸¸ä½¿ç”¨Â `cv2.CV_64F`ã€‚
- `ksize`ï¼šLaplacian æ ¸çš„å¤§å°ï¼Œé»˜è®¤ä¸º 1ã€‚
- `scale`ï¼šç¼©æ”¾å› å­ï¼Œé»˜è®¤ä¸º 1ã€‚
- `delta`ï¼šå¯é€‰çš„ delta å€¼ï¼Œé»˜è®¤ä¸º 0ã€‚
- `borderType`ï¼šè¾¹ç•Œå¡«å……ç±»å‹ï¼Œé»˜è®¤ä¸ºÂ `cv2.BORDER_DEFAULT`ã€‚

|**å‡½æ•°**|**ç®—æ³•**|**ä¼˜ç‚¹**|**ç¼ºç‚¹**|**é€‚ç”¨åœºæ™¯**|
|---|---|---|---|---|
|**`cv2.Canny()`**|Canny è¾¹ç¼˜æ£€æµ‹|å™ªå£°æŠ‘åˆ¶èƒ½åŠ›å¼ºï¼Œè¾¹ç¼˜æ£€æµ‹æ•ˆæœå¥½ã€‚|å‚æ•°è°ƒèŠ‚è¾ƒä¸ºå¤æ‚ã€‚|é€šç”¨è¾¹ç¼˜æ£€æµ‹ï¼Œé€‚åˆå¤§å¤šæ•°åœºæ™¯ã€‚|
|**`cv2.Sobel()`**|Sobel ç®—å­|è®¡ç®—ç®€å•ï¼Œé€‚åˆæ£€æµ‹æ°´å¹³å’Œå‚ç›´è¾¹ç¼˜ã€‚|å¯¹å™ªå£°æ•æ„Ÿï¼Œè¾¹ç¼˜æ£€æµ‹æ•ˆæœä¸€èˆ¬ã€‚|æ£€æµ‹æ°´å¹³å’Œå‚ç›´è¾¹ç¼˜ã€‚|
|**`cv2.Scharr()`**|Scharr ç®—å­|å¯¹è¾¹ç¼˜çš„å“åº”æ›´å¼ºï¼Œé€‚åˆæ£€æµ‹ç»†å¾®è¾¹ç¼˜ã€‚|å¯¹å™ªå£°æ•æ„Ÿã€‚|æ£€æµ‹ç»†å¾®çš„è¾¹ç¼˜ã€‚|
|**`cv2.Laplacian()`**|Laplacian ç®—å­|å¯ä»¥æ£€æµ‹è¾¹ç¼˜å’Œè§’ç‚¹ã€‚|å¯¹å™ªå£°éå¸¸æ•æ„Ÿã€‚|æ£€æµ‹è¾¹ç¼˜å’Œè§’ç‚¹ã€‚|
```python
import cv2 as cv
img = cv.imread('image\\tv.jpg')
gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)

sobelx = cv.Sobel(gray, cv.CV_64F, 1, 0) # ä½¿ç”¨ Sobel
sobely = cv.Sobel(gray, cv.CV_64F, 0, 1) # ä½¿ç”¨ Sobel

edge = cv.Canny(gray, 100, 200)          # ä½¿ç”¨ Canny
cv.imshow('Canny', edge)    # äºŒå€¼å›¾åƒ
cv.imshow('x', sobelx)      # ç°åº¦å›¾
cv.imshow('y', sobely)

cv.waitKey(0)
cv.destroyAllWindows()
```
![[Pasted image 20251218101143.png]]

# è½®å»“æ£€æµ‹ä¸å‡ ä½•åˆ†æ

- ä¸ºäº†è·å¾—æ›´å¥½çš„ç²¾åº¦ï¼Œè¯·ä½¿ç”¨äºŒå€¼å›¾åƒã€‚ å› æ­¤ï¼Œåœ¨æŸ¥æ‰¾è½®å»“ä¹‹å‰ï¼Œè¯·åº”ç”¨é˜ˆå€¼æˆ– canny è¾¹ç¼˜æ£€æµ‹ã€‚
- è‡ª OpenCV 3.2 èµ·ï¼ŒfindContours() ä¸å†ä¿®æ”¹æºå›¾åƒã€‚
- åœ¨ OpenCV ä¸­ï¼ŒæŸ¥æ‰¾è½®å»“å°±åƒä»é»‘è‰²èƒŒæ™¯ä¸­æŸ¥æ‰¾ç™½è‰²å¯¹è±¡ã€‚ æ‰€ä»¥è¯·è®°ä½ï¼Œè¦æŸ¥æ‰¾çš„å¯¹è±¡åº”è¯¥æ˜¯ç™½è‰²ï¼ŒèƒŒæ™¯åº”è¯¥æ˜¯é»‘è‰²ã€‚

## æŸ¥æ‰¾è½®å»“

`contours, hierarchy = cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])`

- `image`: è¾“å…¥çš„äºŒå€¼å›¾åƒï¼ˆé€šå¸¸ä¸ºç»è¿‡é˜ˆå€¼å¤„ç†æˆ–è¾¹ç¼˜æ£€æµ‹åçš„å›¾åƒï¼‰ã€‚
- `mode`: è½®å»“æ£€ç´¢æ¨¡å¼ï¼Œå¸¸ç”¨çš„æœ‰ï¼š
    - `cv2.RETR_EXTERNAL`: åªæ£€æµ‹æœ€å¤–å±‚è½®å»“ã€‚
    - `cv2.RETR_LIST`: æ£€æµ‹æ‰€æœ‰è½®å»“ï¼Œä½†ä¸å»ºç«‹å±‚æ¬¡å…³ç³»ã€‚
    - `cv2.RETR_TREE`: æ£€æµ‹æ‰€æœ‰è½®å»“ï¼Œå¹¶å»ºç«‹å®Œæ•´çš„å±‚æ¬¡ç»“æ„ã€‚
- `method`: è½®å»“è¿‘ä¼¼æ–¹æ³•ï¼Œå¸¸ç”¨çš„æœ‰ï¼š
    - `cv2.CHAIN_APPROX_NONE`: å­˜å‚¨æ‰€æœ‰çš„è½®å»“ç‚¹ã€‚
    - `cv2.CHAIN_APPROX_SIMPLE`: å‹ç¼©æ°´å¹³ã€å‚ç›´å’Œå¯¹è§’çº¿æ®µï¼Œåªä¿ç•™ç«¯ç‚¹ã€‚
- `contours`: è¾“å‡ºçš„è½®å»“åˆ—è¡¨ï¼Œæ¯ä¸ªè½®å»“æ˜¯ä¸€ä¸ªç‚¹é›†ã€‚
- `hierarchy`: è¾“å‡ºçš„å±‚æ¬¡ç»“æ„ä¿¡æ¯ã€‚
- `offset`: å¯é€‰å‚æ•°ï¼Œè½®å»“ç‚¹çš„åç§»é‡ã€‚

è¾“å‡ºè½®å»“æ˜¯å›¾åƒä¸­æ‰€æœ‰è½®å»“çš„ Python åˆ—è¡¨ã€‚ æ¯ä¸ªå•ç‹¬çš„è½®å»“éƒ½æ˜¯å¯¹è±¡è¾¹ç•Œç‚¹çš„ `(x,y)` åæ ‡çš„ `Numpy` æ•°ç»„ï¼Œå½¢çŠ¶ï¼š`(N,1,2)`

## ç»˜åˆ¶è½®å»“

`cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]])`
- `image`: è¦ç»˜åˆ¶è½®å»“çš„å›¾åƒã€‚
- `contours`: è½®å»“åˆ—è¡¨ï¼Œå¦‚æœè¦ç»˜åˆ¶å•ä¸ªè½®å»“ï¼Œè¦åŠ ä¸Š`[]`
- `contourIdx`: è¦ç»˜åˆ¶çš„è½®å»“ç´¢å¼•ï¼Œå¦‚æœä¸ºè´Ÿæ•°ï¼Œåˆ™ç»˜åˆ¶æ‰€æœ‰è½®å»“ã€‚
- `color`: è½®å»“çš„é¢œè‰²ã€‚
- `thickness`: è½®å»“çº¿çš„åšåº¦ï¼Œå¦‚æœä¸ºè´Ÿæ•°ï¼Œåˆ™å¡«å……è½®å»“å†…éƒ¨ã€‚
- `lineType`: çº¿å‹ã€‚
- `hierarchy`: è½®å»“çš„å±‚æ¬¡ç»“æ„ä¿¡æ¯ã€‚
- `maxLevel`: ç»˜åˆ¶çš„æœ€å¤§å±‚æ¬¡æ·±åº¦ã€‚
- `offset`: è½®å»“ç‚¹çš„åç§»é‡ã€‚
æ— è¿”å›å€¼ï¼Œç›´æ¥åœ¨è¾“å…¥å›¾åƒä¸Šç»˜åˆ¶è½®å»“ã€‚

```python
from __future__ import print_function
import cv2 as cv
import numpy as np
import argparse
import random as rng
 
rng.seed(12345)
 
def thresh_callback(val):
    threshold = val
 
    # Detect edges using Canny
    canny_output = cv.Canny(src_gray, threshold, threshold * 2)
 
    # Find contours
    contours, hierarchy = cv.findContours(canny_output, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
 
    # Draw contours
    drawing = np.zeros((canny_output.shape[0], canny_output.shape[1], 3), dtype=np.uint8)
    for i in range(len(contours)):
        color = (rng.randint(0,256), rng.randint(0,256), rng.randint(0,256))
        cv.drawContours(drawing, contours, i, color, 2, cv.LINE_8, hierarchy, 0)
 
    # Show in a window
    cv.imshow('Contours', drawing)
 
# Load source image
src = cv.imread('image/fruit.jpeg')

# Convert image to gray and blur it
src_gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)
src_gray = cv.blur(src_gray, (3,3))
 
# Create Window
source_window = 'Source'
cv.namedWindow(source_window)
cv.imshow(source_window, src)
max_thresh = 255
thresh = 100 # initial threshold
cv.createTrackbar('Canny Thresh:', source_window, thresh, max_thresh, thresh_callback)
thresh_callback(thresh)
 
cv.waitKey(0)
cv.destroyAllWindows()
```

## è®¡ç®—è½®å»“ä¿¡æ¯

### é¢ç§¯
`area = cv2.contourArea(contour[, oriented])`
- `contour`: è¾“å…¥çš„è½®å»“ç‚¹é›†ã€‚
- `oriented`: å¯é€‰å‚æ•°ï¼Œå¦‚æœä¸ºTrueï¼Œè¿”å›æœ‰ç¬¦å·çš„é¢ç§¯ã€‚
### å¼§é•¿/å‘¨é•¿
`length = cv2.arcLength(curve, closed)`
- `curve`: è¾“å…¥çš„è½®å»“ç‚¹é›†ã€‚
- `closed`: å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºè½®å»“æ˜¯å¦é—­åˆã€‚

### è¾¹ç•ŒçŸ©å½¢
`x, y, w, h = cv2.boundingRect(points)`
è¿”å›è¾¹ç•ŒçŸ©å½¢çš„å·¦ä¸Šè§’åæ ‡ `(x, y)` å’Œå®½åº¦ `w`ã€é«˜åº¦ `h`ã€‚

### æœ€å°å¤–ç•ŒçŸ©å½¢
`rect = cv2.minAreaRect(points)`
è¿”å›ä¸€ä¸ªæ—‹è½¬çŸ©å½¢ï¼ŒåŒ…å«ä¸­å¿ƒç‚¹ `(x, y)`ã€å®½åº¦ã€é«˜åº¦å’Œæ—‹è½¬è§’åº¦ã€‚

å¯ä»¥åƒä¸‹é¢è¿™æ ·ç»„åˆä½¿ç”¨
```python
rect = cv2.minAreaRect(contour)
box = cv2.boxPoints(rect)
box = np.int0(box)   # è½¬åŒ–ä¸ºæ•´å½¢åæ ‡
cv2.drawContours(image, [box], 0, (0, 0, 255), 2)  # éœ€è¦ä¼ å…¥[box]å³è½®å»“çš„é›†åˆ
```
`box`æ˜¯`(4, 2)`çš„`numpy`æ•°ç»„ï¼ŒåŒ…å«å››ä¸ªé¡¶ç‚¹çš„åæ ‡ï¼Œè™½ç„¶ä¸æ˜¯`(N,1,2)`çš„ï¼Œä½†æ˜¯å¯ä»¥è¢«å…¼å®¹

### æœ€å°å¤–æ¥åœ†

`(center, radius) = cv2.minEnclosingCircle(points)`
è¿”å›åœ†å¿ƒ `(x, y)` å’ŒåŠå¾„ `radius`

### å¤šè¾¹å½¢è¿‘ä¼¼

`approx = cv2.approxPolyDP(curve, epsilon, closed)`
- `curve`: è¾“å…¥çš„è½®å»“ç‚¹é›†ã€‚
- `epsilon`: è¿‘ä¼¼ç²¾åº¦ï¼Œå€¼è¶Šå°ï¼Œè¿‘ä¼¼è¶Šç²¾ç¡®ã€‚
- `closed`: å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºè½®å»“æ˜¯å¦é—­åˆã€‚
è¿”å›è¿‘ä¼¼åçš„å¤šè¾¹å½¢ç‚¹é›†ï¼Œæ˜¯ä¸€ä¸ª`(M, 1, 2)`Â å½¢çŠ¶çš„ NumPy æ•°ç»„

```python
epsilon = 0.01 * cv2.arcLength(contour, True)
approx = cv2.approxPolyDP(contour, epsilon, True)
cv2.drawContours(image, [approx], 0, (0, 255, 0), 2)
```

### å‡¸åŒ…

`hull = cv2.convexHull(points, clockwise=False, returnPoints=True)`
- `clockwise`æ˜¯å¦æŒ‰é¡ºæ—¶é’ˆ
- æ˜¯å¦è¿”å›ç‚¹é›†ï¼Œè‹¥ä¸º`False`åˆ™è¿”å›ç´¢å¼•

## éœå¤«å˜æ¢

### çº¿

`lines = cv.HoughLines(è¾¹ç¼˜å›¾, Ïç²¾åº¦, Î¸ç²¾åº¦, é˜ˆå€¼)`
è¿”å› (Ï,Î¸) å‚æ•°åˆ—è¡¨ï¼Œæ¯ä¸ª (Ï,Î¸)å¯¹åº”ä¸€æ¡ç›´çº¿
```python
import cv2 as cv
import numpy as np

# 1. è¯»å›¾+è¾¹ç¼˜æ£€æµ‹ï¼ˆéœå¤«åªè®¤è¾¹ç¼˜/äºŒå€¼å›¾ï¼‰
img = cv.imread('line.jpg')
gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
edges = cv.Canny(gray, 50, 150)  # è¾¹ç¼˜æ£€æµ‹ï¼Œå¾—åˆ°äºŒå€¼å›¾

# 2. æ ‡å‡†éœå¤«ç›´çº¿æ£€æµ‹
# Ïç²¾åº¦=1ï¼ŒÎ¸ç²¾åº¦=1Â°ï¼Œé˜ˆå€¼=200ï¼ˆç¥¨æ•°â‰¥200æ‰è®¤ä¸ºæ˜¯ç›´çº¿ï¼‰
lines = cv.HoughLines(edges, 1, np.pi/180, 200)

# 3. ç»˜åˆ¶ç›´çº¿ï¼ˆå…³é”®ï¼šæ ¹æ®Ïå’ŒÎ¸è®¡ç®—ç›´çº¿çš„ä¸¤ä¸ªç«¯ç‚¹ï¼‰
for line in lines:
    Ï, Î¸ = line[0]  # æ¯ä¸ªlineæ˜¯(1,2)æ•°ç»„ï¼Œå–Ïå’ŒÎ¸
    a = np.cos(Î¸)
    b = np.sin(Î¸)
    x0 = a * Ï
    y0 = b * Ï
    # è®¡ç®—ç›´çº¿çš„ä¸¤ä¸ªç«¯ç‚¹ï¼ˆéšä¾¿å–ä¸ªé•¿åº¦ï¼Œæ¯”å¦‚1000ï¼‰
    x1 = int(x0 + 1000*(-b))
    y1 = int(y0 + 1000*(a))
    x2 = int(x0 - 1000*(-b))
    y2 = int(y0 - 1000*(a))
    cv.line(img, (x1,y1), (x2,y2), (0,0,255), 2)  # ç”»çº¢è‰²ç›´çº¿

cv.imshow('HoughLines', img)
cv.waitKey(0)
cv.destroyAllWindows()
```


`lines = cv.HoughLinesP(è¾¹ç¼˜å›¾, Ïç²¾åº¦, Î¸ç²¾åº¦, é˜ˆå€¼, æœ€å°ç›´çº¿é•¿åº¦, æœ€å¤§é—´éš™)`

**å‚æ•°è°ƒä¼˜æŠ€å·§**ï¼š
- é˜ˆå€¼è¶Šé«˜ï¼šæ£€æµ‹åˆ°çš„ç›´çº¿è¶Šå°‘ï¼ˆè¶Šä¸¥æ ¼ï¼‰ï¼Œé˜ˆå€¼è¶Šä½ï¼šæ‚çº¿è¶Šå¤šï¼›
- `minLineLength` è°ƒå¤§ï¼šè¿‡æ»¤æ‰çŸ­çš„æ‚çº¿ï¼›
- `maxLineGap` è°ƒå¤§ï¼šæŠŠæ–­æ–­ç»­ç»­çš„åŒä¸€æ¡ç›´çº¿åˆå¹¶ï¼›

```python
import cv2 as cv
import numpy as np

img = cv.imread('line.jpg')
gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
edges = cv.Canny(gray, 50, 150)

# æ¦‚ç‡éœå¤«ç›´çº¿æ£€æµ‹ï¼ˆé‡ç‚¹çœ‹æ–°å¢å‚æ•°ï¼‰
lines = cv.HoughLinesP(
    edges,
    1,               # Ïç²¾åº¦1åƒç´ 
    np.pi/180,       # Î¸ç²¾åº¦1Â°
    threshold=100,   # é˜ˆå€¼100
    minLineLength=50,# ç›´çº¿æœ€çŸ­50åƒç´ ï¼ˆè¿‡æ»¤çŸ­çº¿æ¡ï¼‰
    maxLineGap=10    # åŒç›´çº¿åƒç´ é—´éš™â‰¤10åƒç´ å°±åˆå¹¶
)

# ç»˜åˆ¶ç›´çº¿ï¼ˆç›´æ¥ç”¨èµ·ç‚¹ç»ˆç‚¹ï¼Œè¶…ç®€å•ï¼ï¼‰
for line in lines:
    x1,y1,x2,y2 = line[0]  # æ¯ä¸ªlineæ˜¯(1,4)æ•°ç»„ï¼Œç›´æ¥å–å››ä¸ªåæ ‡
    cv.line(img, (x1,y1), (x2,y2), (0,255,0), 2)  # ç”»ç»¿è‰²ç›´çº¿

cv.imshow('HoughLinesP', img)
cv.waitKey(0)
cv.destroyAllWindows()
```
### åœ†

```python
circles = cv.HoughCircles(
    image,          # è¾“å…¥å›¾åƒï¼ˆå¿…é¡»æ˜¯ç°åº¦å›¾ï¼ï¼‰
    method,         # æ£€æµ‹æ–¹æ³•ï¼Œå›ºå®šä¼  cv.HOUGH_GRADIENTï¼ˆå”¯ä¸€å®ç”¨çš„æ–¹æ³•ï¼‰
    dp,             # åˆ†è¾¨ç‡åæ¯”å› å­ï¼ˆæ ¸å¿ƒå‚æ•°ï¼‰
    minDist,        # ä¸¤ä¸ªåœ†å¿ƒä¹‹é—´çš„æœ€å°è·ç¦»ï¼ˆé˜²é‡å¤æ£€æµ‹ï¼‰
    param1=None,    # å¯¹åº”Cannyè¾¹ç¼˜æ£€æµ‹çš„é«˜é˜ˆå€¼ï¼ˆä½é˜ˆå€¼æ˜¯å®ƒçš„1/2ï¼‰
    param2=None,    # ç´¯åŠ å™¨é˜ˆå€¼ï¼ˆåœ†çš„â€œæŠ•ç¥¨æ•°â€ï¼Œè¶Šå°æ£€æµ‹è¶Šå¤šåœ†ï¼‰
    minRadius=None, # åœ†çš„æœ€å°åŠå¾„ï¼ˆè¿‡æ»¤å°æ‚åœ†ï¼‰
    maxRadius=None  # åœ†çš„æœ€å¤§åŠå¾„ï¼ˆè¿‡æ»¤å¤§æ‚åœ†ï¼‰
)
```
è¿”å›å€¼æ˜¯ä¸€ä¸ª**ä¸‰ç»´ NumPy æ•°ç»„**ï¼ˆå½¢çŠ¶ä¸ºÂ `(1, N, 3)`ï¼Œ`N`Â æ˜¯æ£€æµ‹åˆ°çš„åœ†çš„æ•°é‡ï¼‰æˆ–`None`

| å‚æ•°          | æŠ€å·§                                                                                                                    |
| ----------- | --------------------------------------------------------------------------------------------------------------------- |
| `dp`        | ğŸ‘‰ æ ¸å¿ƒï¼åˆ†è¾¨ç‡åæ¯”å› å­ï¼š<br><br>-Â `dp=1`ï¼šæ£€æµ‹åˆ†è¾¨ç‡å’ŒåŸå›¾ä¸€è‡´ï¼›<br><br>-Â `dp=2`ï¼šæ£€æµ‹åˆ†è¾¨ç‡æ˜¯åŸå›¾çš„ 1/2ï¼ˆé€Ÿåº¦å¿«ï¼Œç²¾åº¦ç•¥é™ï¼‰ï¼›<br><br>**æ¨èå€¼**ï¼š1~1.5ï¼ˆå¹³è¡¡é€Ÿåº¦å’Œç²¾åº¦ï¼‰ï¼›    |
| `minDist`   | ä¸¤ä¸ªåœ†å¿ƒä¹‹é—´çš„æœ€å°åƒç´ è·ç¦»ï¼š<br>**æ¨èå€¼**ï¼šè‡³å°‘è®¾ä¸º â€œé¢„æœŸåœ†ç›´å¾„çš„ 1/2â€ï¼ˆæ¯”å¦‚æ£€æµ‹åŠå¾„ 20 çš„åœ†ï¼ŒminDistâ‰¥20ï¼‰ï¼›                                                 |
| `param1`    | ä¼ ç»™ Canny è¾¹ç¼˜æ£€æµ‹çš„**é«˜é˜ˆå€¼**ï¼ˆä½é˜ˆå€¼è‡ªåŠ¨æ˜¯å®ƒçš„ 1/2ï¼‰ï¼š<br><br>- å¤ªå¤§ï¼šè¾¹ç¼˜å°‘ï¼Œæ¼æ£€åœ†ï¼›<br><br>- å¤ªå°ï¼šè¾¹ç¼˜å¤šï¼Œæ‚åœ†å¤šï¼›<br><br>**æ¨èå€¼**ï¼š50~150ï¼ˆå’Œ Canny è°ƒå‚é€»è¾‘ä¸€è‡´ï¼‰ï¼› |
| `param2`    | åœ†çš„ â€œæŠ•ç¥¨é˜ˆå€¼â€ï¼š<br><br>- è¶Šå°ï¼šæ£€æµ‹åˆ°çš„åœ†è¶Šå¤šï¼ˆä½†æ‚åœ†ã€å‡åœ†ä¹Ÿå¤šï¼‰ï¼›<br><br>- è¶Šå¤§ï¼šåªæ£€æµ‹æœ€æ˜æ˜¾çš„åœ†ï¼ˆæ¼æ£€å¼±è¾¹ç¼˜çš„åœ†ï¼‰ï¼›<br><br>**æ¨èå€¼**ï¼š20~50ï¼ˆæ ¸å¿ƒè°ƒå‚ï¼Œå†³å®šæ£€æµ‹æ•°é‡ï¼‰ï¼›           |
| `minRadius` | æœ€å°åŠå¾„ï¼šè¿‡æ»¤æ‰æ¯”è¿™ä¸ªå°çš„æ‚åœ†ï¼ˆæ¯”å¦‚å›¾åƒä¸­çš„å™ªç‚¹å°åœ†ï¼‰ï¼›                                                                                          |
| `maxRadius` | æœ€å¤§åŠå¾„ï¼šè¿‡æ»¤æ‰æ¯”è¿™ä¸ªå¤§çš„æ— å…³åœ†ï¼›è‹¥è®¾ä¸º 0/Noneï¼Œè‡ªåŠ¨æ£€æµ‹æ‰€æœ‰å¯èƒ½çš„åŠå¾„ï¼›                                                                              |
```python
import cv2
import numpy as np

# æ­¥éª¤1ï¼šè¯»å–å›¾åƒâ†’è½¬ç°åº¦â†’é™å™ªï¼ˆå…³é”®ï¼åœ†æ£€æµ‹å¯¹å™ªå£°ææ•æ„Ÿï¼‰
img = cv2.imread('circles.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# é«˜æ–¯æ¨¡ç³Šé™å™ªï¼ˆå¿…é¡»åšï¼å¦åˆ™æ‚ç‚¹ä¼šè¢«è¯¯æ£€ä¸ºåœ†ï¼‰
blur = cv2.GaussianBlur(gray, (5,5), 0)  # æ ¸è¶Šå¤§ï¼Œé™å™ªè¶Šå¼ºï¼ˆä½†è¾¹ç¼˜ä¼šæ¨¡ç³Šï¼‰

# æ­¥éª¤2ï¼šéœå¤«åœ†æ£€æµ‹ï¼ˆæ ¸å¿ƒå‚æ•°æŒ‰åœºæ™¯è°ƒï¼‰
circles = cv2.HoughCircles(
    blur,                      # é™å™ªåçš„ç°åº¦å›¾
    cv.HOUGH_GRADIENT,         # å›ºå®šæ–¹æ³•
    dp=1,                      # åˆ†è¾¨ç‡å’ŒåŸå›¾ä¸€è‡´
    minDist=30,                # åœ†å¿ƒæœ€å°è·ç¦»30åƒç´ 
    param1=100,                # Cannyé«˜é˜ˆå€¼100ï¼ˆä½é˜ˆå€¼50ï¼‰
    param2=30,                 # æŠ•ç¥¨é˜ˆå€¼30
    minRadius=10,              # æœ€å°åŠå¾„10
    maxRadius=50               # æœ€å¤§åŠå¾„50
)

# æ­¥éª¤3ï¼šç»˜åˆ¶æ£€æµ‹åˆ°çš„åœ†ï¼ˆæ³¨æ„ç±»å‹è½¬æ¢ï¼‰
if circles is not None:
    # éœå¤«åœ†è¿”å›çš„æ˜¯æµ®ç‚¹å‹åæ ‡ï¼Œéœ€è½¬æ•´æ•°
    circles = np.uint16(np.around(circles))
    # éå†æ¯ä¸ªæ£€æµ‹åˆ°çš„åœ†
    for circle in circles[0, :]:
        x, y, r = circle[0], circle[1], circle[2]
        # ç”»åœ†å¿ƒï¼ˆçº¢è‰²åœ†ç‚¹ï¼‰
        cv2.circle(img, (x, y), 2, (0, 0, 255), -1)
        # ç”»åœ†å‘¨ï¼ˆç»¿è‰²çº¿æ¡ï¼Œå®½åº¦2ï¼‰
        cv2.circle(img, (x, y), r, (0, 255, 0), 2)

# æ­¥éª¤4ï¼šæ˜¾ç¤ºç»“æœ
cv2.imshow('Detected Circles', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```


```python
import cv2 as cv
import numpy as np

img = cv.imread('./image/star.jpeg')
gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
edge = cv.Canny(gray, 100, 200)

# ç»˜åˆ¶è½®å»“
canvas = np.zeros((img.shape[0], img.shape[1], img.shape[2]), dtype= np.uint8)
contours, _ = cv.findContours(edge, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
cv.drawContours(canvas, contours, -1, (0, 0, 255), 2)

# è¾¹ç•ŒçŸ©å½¢
for contour in contours:
    x, y, w, h = cv.boundingRect(contour)
    cv.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 1)

# è¾¹ç•Œåœ†
for contour in contours:
    (x, y), radius = cv.minEnclosingCircle(contour)
    center = (int(x), int(y))
    radius = int(radius)
    cv.circle(img, center, radius, (255,0,0),3)

# å‡¸åŒ…
for contour in contours:
    hull = cv.convexHull(contour)
    cv.drawContours(canvas, [hull], 0, (0, 255, 0), 2)  # æ³¨æ„ä½¿ç”¨è¾¹ç•Œçš„é›†åˆ

# éœå¤«çº¿å˜æ¢
lines = cv.HoughLinesP(edge, 1, np.pi/180, threshold=100, minLineLength= 5)
for line in lines:
    x1,y1,x2,y2 = line[0]
    edge = cv.cvtColor(edge, 1)
    cv.line(edge, (x1,y1), (x2,y2), (0,255,0), 2)

# éœå¤«åœ†å˜æ¢ï¼ˆä½¿ç”¨ç°åº¦å›¾ï¼‰
blur = cv.GaussianBlur(gray, (5,5), 0)
circles = cv.HoughCircles(blur, cv.HOUGH_GRADIENT, dp=1, minDist=30,
                        param1=100, param2= 30, 
                        minRadius=10, maxRadius= 100)
if circles is not None:
    circles = np.uint16(np.around(circles))  # æ³¨æ„è¦è½¬åŒ–ä¸ºæ•´æ•°
    gray = cv.cvtColor(gray, 1)
    for circle in circles[0]:
        x, y, r = circle
        cv.circle(gray, (x, y), r, (255,0,0), 2)

cv.imshow('origin', img)     # è¾¹ç•ŒçŸ©å½¢(G)ã€è¾¹ç•Œåœ†(B)
cv.imshow('edge', edge)      # éœå¤«çº¿(G)
cv.imshow('gray', gray)      # éœå¤«åœ†(B)
cv.imshow('contour', canvas)  # ç»˜åˆ¶è½®å»“(R)ã€å‡¸åŒ…(G)
cv.waitKey(0)
cv.destroyAllWindows()
```

![[Pasted image 20251219084901.png]]

å¤šè¾¹å½¢è¿‘ä¼¼ï¼Œè½®å»“é¢ç§¯ã€å‘¨é•¿
```python
import cv2 as cv

cap = cv.VideoCapture(0)
while cap.isOpened():
    _, img = cap.read()
    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    edge = cv.Canny(gray, 50, 150)
    contours, _ = cv.findContours(edge, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)

    for contour in contours:

        # è¿‡æ»¤
        if cv.contourArea(contour) < 50:
            continue

        # å¤šè¾¹å½¢é€¼è¿›
        epsilon = cv.arcLength(contour, True) * 0.01
        approx = cv.approxPolyDP(contour, epsilon, True)

        # åˆ¤æ–­å½¢çŠ¶
        if len(approx) == 3:
            label = 'Triangle'
        elif len(approx) == 4:
            label = 'Rectangle'
        else:
            label = 'Arch'
        
        # ç»˜åˆ¶ï¼Œè´´æ ‡ç­¾
        x, y = approx[0][0]
        cv.putText(img, label, (x, y+10), cv.FONT_HERSHEY_SIMPLEX, 0.8, (0,255,0))
        cv.drawContours(img, [approx], 0, (127,64,255), 2)

    cv.imshow('origin', img)
    cv.imshow('edge', edge)
    if cv.waitKey(30) == ord('q'):
        break
cv.destroyAllWindows()
```

# HOGç‰¹å¾ä¸SVMåˆ†ç±»

## HOG

HOG å°†å›¾åƒæ‹†åˆ†ä¸ºå±€éƒ¨å°åŒºåŸŸï¼Œé€šè¿‡ç»Ÿè®¡æ¯ä¸ªå°åŒºåŸŸçš„æ¢¯åº¦æ–¹å‘åˆ†å¸ƒï¼ŒæŠ½è±¡æˆç‰¹å¾å‘é‡ï¼›è¿™ä¸ªç‰¹å¾å‘é‡æ•´ä½“æè¿°äº†å›¾åƒä¸­ã€Œå±€éƒ¨è½®å»“ / çº¹ç†çš„æ–¹å‘åˆ†å¸ƒè§„å¾‹ã€ï¼Œè€Œéå•ä¸€çš„æ•´ä½“è½®å»“æ–¹å‘ã€‚

```python
# 1. åˆå§‹åŒ–HOGç‰¹å¾æå–å™¨
hog = cv.HOGDescriptor(
    _winSize,       # HOGçª—å£å¤§å°ï¼ˆå¿…é¡»ç­‰äºè¾“å…¥å›¾åƒå°ºå¯¸ï¼Œå¦‚(64,64)ï¼‰
    _blockSize,     # Blockå¤§å°ï¼ˆå¦‚(16,16)ï¼Œæ¯ä¸ªBlockåŒ…å«2Ã—2ä¸ªCellï¼‰
    _blockStride,   # Blockæ»‘åŠ¨æ­¥é•¿ï¼ˆå¦‚(8,8)ï¼Œä¿è¯Blocké—´æœ‰50%é‡å ï¼‰
    _cellSize,      # Cellå¤§å°ï¼ˆå¦‚(8,8)ï¼Œæœ€å°æ¢¯åº¦ç»Ÿè®¡å•å…ƒï¼‰
    _nbins,         # æ¢¯åº¦æ–¹å‘åˆ†ç®±æ•°ï¼ˆå¦‚9ï¼Œ0~180Â°å‡åˆ†9ä¸ªåŒºé—´ï¼‰
    
    _derivAperture=1,  # æ¢¯åº¦è®¡ç®—çš„å­”å¾„å¤§å°ï¼ˆå›ºå®šä¸º1å³å¯ï¼‰
    _winSigma=-1,   # çª—å£é«˜æ–¯å¹³æ»‘ç³»æ•°ï¼ˆ-1ä¸ºè‡ªåŠ¨è®¡ç®—ï¼Œé™å™ªç”¨ï¼‰
    _histogramNormType=0,  # ç›´æ–¹å›¾å½’ä¸€åŒ–ç±»å‹ï¼ˆå›ºå®š0ï¼‰
    _L2HysThreshold=0.2,   # L2-Hyså½’ä¸€åŒ–é˜ˆå€¼ï¼ˆæ§åˆ¶å½’ä¸€åŒ–å¼ºåº¦ï¼‰
    _gammaCorrection=True, # æ˜¯å¦ä¼½é©¬æ ¡æ­£ï¼ˆTrueï¼šé™ä½å…‰ç…§å½±å“ï¼‰
    _nlevels=64     # æ£€æµ‹çš„å°ºåº¦å±‚æ•°ï¼ˆä»…é¢„è®­ç»ƒæ£€æµ‹å™¨ç”Ÿæ•ˆï¼‰
)

# 2. æå–å•å¼ å›¾åƒçš„HOGç‰¹å¾
hog_feature = hog.compute(
    img,            # è¾“å…¥å›¾åƒï¼ˆå¿…é¡»æ˜¯ç°åº¦å›¾ï¼Œå°ºå¯¸åŒ¹é…_winSizeï¼‰
    winStride=(8,8),# çª—å£æ­¥é•¿ï¼ˆä»…å¤šå°ºåº¦æ£€æµ‹ç”Ÿæ•ˆï¼Œå•å›¾ä¼ é»˜è®¤å³å¯ï¼‰
    padding=(0,0),  # å›¾åƒè¾¹ç¼˜å¡«å……ï¼ˆä»…å¤šå°ºåº¦æ£€æµ‹ç”Ÿæ•ˆï¼‰
    locations=()    # æ£€æµ‹ä½ç½®ï¼ˆç©ºåˆ™éå†å…¨å›¾ï¼‰
)  # è¿”å›å€¼ï¼š(ç‰¹å¾ç»´åº¦, 1)çš„äºŒç»´æ•°ç»„ï¼Œéœ€flatten()è½¬ä¸ºä¸€ç»´
hog_feature = hog.compute(img).flatten()

# 3. ç»‘å®šé¢„è®­ç»ƒSVMæ£€æµ‹å™¨ï¼ˆç”¨äºå¿«é€Ÿç›®æ ‡æ£€æµ‹ï¼‰
hog.setSVMDetector(
    detector        # é¢„è®­ç»ƒæ£€æµ‹å™¨ï¼Œå¦‚cv.HOGDescriptor_getDefaultPeopleDetector()ï¼ˆè¡Œäººæ£€æµ‹ï¼‰
)  # æ— è¿”å›å€¼ï¼Œç›´æ¥ç»‘å®šSVMæ¨¡å‹åˆ°HOGå¯¹è±¡

# 4. ç”¨é¢„è®­ç»ƒHOG+SVMæ£€æµ‹ç›®æ ‡
rects, weights = hog.detectMultiScale(
    img,            # è¾“å…¥å›¾åƒï¼ˆå½©è‰²/ç°åº¦å‡å¯ï¼‰
    winStride=(8,8),# æ»‘åŠ¨çª—å£æ­¥é•¿ï¼ˆè¶Šå°æ£€æµ‹è¶Šå‡†ï¼Œé€Ÿåº¦è¶Šæ…¢ï¼‰
    padding=(16,16),# å›¾åƒè¾¹ç¼˜å¡«å……ï¼ˆé¿å…æ¼æ£€è¾¹ç¼˜ç›®æ ‡ï¼‰
    scale=1.05,     # å¤šå°ºåº¦æ£€æµ‹å› å­ï¼ˆè¶Šå°æ£€æµ‹è¶Šå°ç›®æ ‡ï¼Œé€Ÿåº¦è¶Šæ…¢ï¼‰
    finalThreshold=2.0,  # æœ€ç»ˆæ£€æµ‹é˜ˆå€¼ï¼ˆè¿‡æ»¤ä½ç½®ä¿¡åº¦ç»“æœï¼‰
    useMeanshiftGrouping=False  # æ˜¯å¦èšç±»é‡å æ¡†ï¼ˆFalseå³å¯ï¼‰
)  # rectsï¼šæ£€æµ‹åˆ°çš„ç›®æ ‡æ¡†åˆ—è¡¨[(x,y,w,h), ...]ï¼›weightsï¼šæ¯ä¸ªæ¡†çš„ç½®ä¿¡åº¦æ•°ç»„
```
## SVM

ä¸€ç§åˆ¤åˆ«åˆ†ç¦»å™¨ï¼Œé€šè¿‡ç›‘ç£å­¦ä¹ ï¼Œè¾“å‡ºä¸€ä¸ªç”¨äºåˆ†ç±»çš„è¶…å¹³é¢ï¼Œå¯¹å…¶æ–°æ ·æœ¬åˆ†ç±»
```python
# 1. åˆå§‹åŒ–SVMåˆ†ç±»å™¨
svm = cv.ml.SVM_create()

# 2. è®¾ç½®SVMæ ¸å‡½æ•°
svm.setKernel(
    kernel_type     # æ ¸å‡½æ•°ç±»å‹ï¼š
                    # cv.ml.SVM_LINEARï¼ˆçº¿æ€§æ ¸ï¼Œç®€å•äºŒåˆ†ç±»é¦–é€‰ï¼‰
                    # cv.ml.SVM_RBFï¼ˆé«˜æ–¯æ ¸ï¼Œéçº¿æ€§åˆ†ç±»ï¼‰
                    # cv.ml.SVM_POLYï¼ˆå¤šé¡¹å¼æ ¸ï¼Œå¤æ‚éçº¿æ€§ï¼‰
)  # æ— è¿”å›å€¼

# 3. è®¾ç½®SVMåˆ†ç±»ç±»å‹
svm.setType(
    type            # ç±»å‹ï¼š
                    # cv.ml.SVM_C_SVCï¼ˆC-SVCäºŒåˆ†ç±»ï¼Œæœ€å¸¸ç”¨ï¼‰
                    # cv.ml.SVM_NU_SVCï¼ˆÎ½-SVCäºŒåˆ†ç±»ï¼Œæ§åˆ¶æ”¯æŒå‘é‡æ¯”ä¾‹ï¼‰
                    # cv.ml.SVM_REGRESSIONï¼ˆå›å½’ä»»åŠ¡ï¼‰
)  # æ— è¿”å›å€¼

# 4. è®¾ç½®æƒ©ç½šç³»æ•°C
svm.setC(
    C               # æƒ©ç½šç³»æ•°ï¼ˆfloatï¼‰ï¼š
                    # è¶Šå¤§â†’å¯¹è¯¯åˆ†ç±»æ ·æœ¬æƒ©ç½šè¶Šé‡ï¼Œæ˜“è¿‡æ‹Ÿåˆ
                    # è¶Šå°â†’å®¹é”™ç‡é«˜ï¼Œæ˜“æ¬ æ‹Ÿåˆï¼ˆæ¨è0.1~10ï¼‰
)  # æ— è¿”å›å€¼

# 5. è®¾ç½®é«˜æ–¯æ ¸å‚æ•°gammaï¼ˆä»…RBF/å¤šé¡¹å¼æ ¸ç”Ÿæ•ˆï¼‰
svm.setGamma(
    gamma           # gammaå€¼ï¼ˆfloatï¼‰ï¼š
                    # è¶Šå¤§â†’ç‰¹å¾æ˜ å°„è¶Šå¤æ‚ï¼Œæ˜“è¿‡æ‹Ÿåˆ
                    # è¶Šå°â†’æ¨¡å‹è¶Šç®€å•ï¼Œæ˜“æ¬ æ‹Ÿåˆï¼ˆæ¨è0.01~1ï¼‰
)  # æ— è¿”å›å€¼

# 6. è®­ç»ƒSVMæ¨¡å‹
ret = svm.train(
    train_data,     # è®­ç»ƒç‰¹å¾æ•°æ®ï¼ˆnp.float32ç±»å‹ï¼Œå½¢çŠ¶=(æ ·æœ¬æ•°, ç‰¹å¾ç»´åº¦)ï¼‰
    sample_layout,  # æ ·æœ¬å¸ƒå±€ï¼šcv.ml.ROW_SAMPLEï¼ˆæ¯è¡Œä¸€ä¸ªæ ·æœ¬ï¼Œå¿…é€‰ï¼‰
    train_labels    # è®­ç»ƒæ ‡ç­¾ï¼ˆnp.int32ç±»å‹ï¼Œå½¢çŠ¶=(æ ·æœ¬æ•°,)ï¼‰
)  # retï¼šè®­ç»ƒæ˜¯å¦æˆåŠŸï¼ˆboolï¼‰
ret = svm.trainAuto(
	train_data,     # è®­ç»ƒç‰¹å¾æ•°æ®ï¼ˆnp.float32ç±»å‹ï¼Œå½¢çŠ¶=(æ ·æœ¬æ•°, ç‰¹å¾ç»´åº¦)ï¼‰
    sample_layout,  # æ ·æœ¬å¸ƒå±€ï¼šcv.ml.ROW_SAMPLEï¼ˆæ¯è¡Œä¸€ä¸ªæ ·æœ¬ï¼Œå¿…é€‰ï¼‰
    train_labels    # è®­ç»ƒæ ‡ç­¾ï¼ˆnp.int32ç±»å‹ï¼Œå½¢çŠ¶=(æ ·æœ¬æ•°,)ï¼‰
    kFold           # è¶Šå¤§è¶Šå‡†ï¼Œä½†è®­ç»ƒæ…¢
)

# 7. SVMé¢„æµ‹
_, pred_labels = svm.predict(
    test_data       # æµ‹è¯•ç‰¹å¾æ•°æ®ï¼ˆæ ¼å¼ä¸train_dataä¸€è‡´ï¼Œæ”¯æŒå•æ ·æœ¬/æ‰¹é‡ï¼‰
)  # _ï¼šé¢„æµ‹ç½®ä¿¡åº¦ï¼ˆå¿½ç•¥å³å¯ï¼‰ï¼›pred_labelsï¼šé¢„æµ‹æ ‡ç­¾ï¼ˆäºŒç»´æ•°ç»„(æ ·æœ¬æ•°,1)ï¼Œåˆ—å‘é‡ï¼‰

# 8. ä¿å­˜/åŠ è½½SVMæ¨¡å‹
svm.save(
    file_path       # æ¨¡å‹ä¿å­˜è·¯å¾„ï¼ˆå¦‚"hog_svm.xml"ï¼‰
)  # æ— è¿”å›å€¼

svm = cv.ml.SVM_load(
    file_path       # æ¨¡å‹åŠ è½½è·¯å¾„
)  # è¿”å›åŠ è½½åçš„SVMå¯¹è±¡
```

## è°ƒç”¨é“¾

```python
# 1. HOGåˆå§‹åŒ–
hog = cv2.HOGDescriptor((64,64), (16,16), (8,8), (8,8), 9)
# 2. æå–HOGç‰¹å¾ï¼ˆè®­ç»ƒ/æµ‹è¯•é›†ï¼‰
train_feature = hog.compute(train_img).flatten()  # å•å¼ å›¾åƒ
train_data = np.array(all_train_features, dtype=np.float32)  # æ‰¹é‡ç‰¹å¾
# 3. SVMåˆå§‹åŒ–ä¸å‚æ•°é…ç½®
svm = cv2.ml.SVM_create()
svm.setKernel(cv2.ml.SVM_LINEAR)
svm.setType(cv2.ml.SVM_C_SVC)
svm.setC(1.0)
# 4. è®­ç»ƒSVM
svm.train(train_data, cv2.ml.ROW_SAMPLE, train_labels)
# 5. é¢„æµ‹
test_feature = hog.compute(test_img).flatten().reshape(1, -1)  # å•æ ·æœ¬reshapeä¸º(1, ç‰¹å¾ç»´åº¦)
_, pred = svm.predict(test_feature)
# 6. æ¨¡å‹ä¿å­˜/åŠ è½½
svm.save("hog_svm.xml")
svm = cv2.ml.SVM_load("hog_svm.xml")
```

## å®ä¾‹

```python
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_digits
import cv2 as cv
import numpy as np

# åŠ è½½æ•°æ®
digits = load_digits()
x, y = digits.images, digits.target

# æå–HOGç‰¹å¾
hog = cv.HOGDescriptor((8, 8), (2, 2), (1, 1), (1, 1), 9) 
x_HOG = []
for img in x:
    img_uint8 = np.array((img * 16), dtype=np.uint8)
    fd = hog.compute(img_uint8).flatten()
    x_HOG.append(fd)
x_HOG = np.array(x_HOG, dtype= np.float32)  # ä¸ºä»€ä¹ˆè¦è½¬åŒ–ç±»å‹ï¼ˆå¼ºåˆ¶è¦æ±‚ï¼‰
y = np.array(y, dtype= np.int32)            # ä¸ºä»€ä¹ˆè¦è½¬åŒ–ç±»å‹ï¼ˆå¼ºåˆ¶è¦æ±‚ï¼‰

# åˆ’åˆ†è®­ç»ƒé›†/æµ‹è¯•é›†ï¼ˆåŒæ—¶ä¿ç•™åŸå§‹å›¾åƒç”¨äºå¯è§†åŒ–ï¼‰
X_train, X_test, y_train, y_test, imgs_train, imgs_test = train_test_split(
    x_HOG, y, x, test_size=0.1, random_state=40
)                                           # è¿™ä¸ªå‡½æ•°åœ¨å¹²ä»€ä¹ˆ

# åˆ›å»ºè®­ç»ƒSVM
svm = cv.ml.SVM_create()
svm.setKernel(cv.ml.SVM_LINEAR)
svm.setType(cv.ml.SVM_C_SVC)
svm.setTermCriteria((cv.TERM_CRITERIA_MAX_ITER, 1000, 1e-6))  # è¿™æ˜¯ä»€ä¹ˆ

print("è®­ç»ƒä¸­â€¦â€¦")
svm.train(X_train, cv.ml.ROW_SAMPLE, y_train)

# è¯„ä¼°å‡†ç¡®ç‡
_, preds = svm.predict(X_test)
preds  = preds.flatten()
accuary = (preds == y_test).mean()
print(f"æ­£ç¡®ç‡ï¼š{(100 * accuary):.2f}%")

# å¯è§†åŒ–æµ‹è¯•
for i in range(5):
    img_ori = imgs_test[i]
    img = (img_ori * 16).astype(np.uint8)
    img = cv.resize(img, (200, 200))
    img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)

    # æ·»åŠ æ–‡å­—
    pred = preds[i]
    real = y_test[i]
    cv.putText(img, f"pred: {pred}", (10, 30), 
               cv.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
    cv.putText(img, f"true: {real}", (10, 60), 
               cv.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
    cv.imshow(f"Sample {i+1}", img)
cv.waitKey(0)
cv.destroyAllWindows()
svm.save("num_recognise.xml")
```
æ³¨æ„è®­ç»ƒæ—¶çš„æ ¼å¼ï¼š`å›¾åƒ((8, 8), uint8`) -> `å•ä¸ªHOG((ç»´åº¦, ))` -> `HOGarray((æ•°ç›®, ç»´åº¦), float32)`

é¢„æµ‹æ—¶çš„æ ¼å¼ï¼šå’Œä¸Šé¢è¦ä¸€è‡´
```python
import cv2 as cv
import numpy as np

svm = cv.ml.SVM_load("num_recognise.xml")
hog = cv.HOGDescriptor((8, 8), (2, 2), (1, 1), (1, 1), 9)

# è¯†åˆ«å›¾åƒä¸­çš„æ•°å­—
def useimg(img = cv.imread('image/IMG_20251221_150348.jpg')):

    # å¦‚æœå›¾åƒå¤ªå¤§ï¼Œç¼©å°å›¾åƒ
    if img.shape[1] > 800:
        ratio = 800 / img.shape[1]
        img = cv.resize(img, None, fx= ratio, fy= ratio)

    # æŠŠå›¾åƒäºŒå€¼åŒ–ï¼ˆè¿˜å¯ä»¥è¿›è¡Œå½¢æ€å­¦æ“ä½œï¼‰
    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    _, img_thr = cv.threshold(img_gray, 96, 255, cv.THRESH_BINARY_INV)

    # kernel = np.ones((3,3),np.uint8)
    # img_thr = cv.morphologyEx(img_thr, cv.MORPH_CLOSE, kernel)
    # cv.imshow('image thresholdq', img_thr)
    # cv.waitKey(0)

    # æå–è½®å»“ä»¥åŠæ•°å­—ä½ç½®ï¼Œæå–ROI_HOG
    contours, _ = cv.findContours(img_thr, cv.RETR_EXTERNAL, 
                                  cv.CHAIN_APPROX_SIMPLE)
    positions = []
    rois_hog = []

    for contour in contours:
        # ç­›é€‰
        area = cv.contourArea(contour)
        if area < 25:
            continue
        x, y, w, h = cv.boundingRect(contour)
        # é¿å…çŸ©å½¢æ¡†å¤ªçª„
        if h / w > 1.5:
            center_x = (x + x + w) // 2
            w = int(h / 1.5)
            x = max(center_x - w // 2, 0)  # é˜²æ­¢è¶Šç•Œ
        
        cv.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)

        positions.append([x, y])

        roi = img_thr[y : y+h, x : x+w]
        roi_small = cv.resize(roi, (8, 8), cv.INTER_NEAREST).astype(np.uint8)

        # cv.imshow('roi', cv.resize(roi_small, (500,500), cv.INTER_NEAREST))
        # cv.waitKey(0)

        roi_hog = hog.compute(roi_small).flatten()
        rois_hog.append(roi_hog)

    rois_hog = np.array(rois_hog, dtype= np.float32)

    # è¯†åˆ«æ•°å­—ï¼Œå¹¶åœ¨å›¾åƒä¸Šå±•ç¤º
    _, nums = svm.predict(rois_hog)
    nums = np.array(nums, dtype= np.uint8).reshape(-1,)
    for (x, y), num in zip(positions, nums):
        cv.putText(img, f'{num}', (x+5, y-10), cv.FONT_HERSHEY_SIMPLEX,
                   0.8, (0, 255, 0), 2)
    cv.imshow('image', img)
    cv.imshow('image_th', img_thr)
    if cv.waitKey(30) == ord('q'):
        exit(0)

# useimg()
cap = cv.VideoCapture(0)
while cap.isOpened():
    _, frame = cap.read()
    useimg(frame)
cap.release()
cv.destroyAllWindows()
```

# é¢œè‰²è¯†åˆ«ä¸ç›®æ ‡è¿½è¸ª

## è®¡ç®—å›¾åƒ / è½®å»“å‡ ä½•çŸ©

`cv.moments(contour)`
- `contour`ï¼šè½®å»“

**è¿”å›å€¼**æ˜¯ä¸€ä¸ªå­—å…¸ï¼š

| é”®      | å«ä¹‰                       | å¸¸ç”¨åœºæ™¯               |
| ------ | ------------------------ | ------------------ |
| `m00`  | é›¶é˜¶çŸ© â†’ è½®å»“é¢ç§¯ï¼ˆç°åº¦å€¼ä¹‹å’Œï¼‰        | åˆ¤æ–­è½®å»“å¤§å°ã€é˜²å¾¡é™¤é›¶        |
| `m10`  | ä¸€é˜¶çŸ©ï¼ˆx æ–¹å‘ï¼‰ï¼ˆç°åº¦å€¼ä½œä¸ºæƒé‡çš„xåæ ‡ä¹‹å’Œï¼‰ | è®¡ç®—é‡å¿ƒ x åæ ‡ï¼ˆm10/m00ï¼‰ |
| `m01`  | ä¸€é˜¶çŸ©ï¼ˆy æ–¹å‘ï¼‰                | è®¡ç®—é‡å¿ƒ y åæ ‡ï¼ˆm01/m00ï¼‰ |
| `mu20` | äºŒé˜¶ä¸­å¿ƒçŸ©                    | è®¡ç®—è½®å»“æ–¹å‘ã€å½¢çŠ¶æ‰ç‡        |
| `nu20` | å½’ä¸€åŒ–äºŒé˜¶ä¸­å¿ƒçŸ©                 | å½¢çŠ¶åŒ¹é…ï¼ˆç¼©æ”¾ä¸å˜ï¼‰         |

## è¿é€šåŒºåŸŸåˆ¤æ–­

`num_labels, labels = cv2.connectedComponents(img, connectivity=8, ltype=cv2.CV_32S)`
- `img`ï¼šå¿…é¡»æ˜¯äºŒå€¼å›¾åƒ
- `connectivity`ï¼šè¿é€šæ–¹å¼ï¼š4ï¼ˆä¸Šä¸‹å·¦å³ï¼‰æˆ– 8ï¼ˆé»˜è®¤ï¼Œå«å¯¹è§’çº¿ï¼‰
- `ltype`ï¼šè¾“å‡ºæ ‡ç­¾çŸ©é˜µçš„æ•°æ®ç±»å‹ï¼Œé»˜è®¤Â `cv2.CV_32S`ï¼ˆ32 ä½æ•´å‹ï¼‰
- `num_labels`ï¼šè¿é€šåŒºåŸŸæ€»æ•°ï¼ˆå«èƒŒæ™¯ï¼ŒèƒŒæ™¯æ˜¯æ ‡ç­¾ 0ï¼‰
- `labels`ï¼šå’Œè¾“å…¥å›¾åƒåŒå°ºå¯¸çš„çŸ©é˜µï¼Œæ¯ä¸ªåƒç´ å€¼æ˜¯å…¶æ‰€å±è¿é€šåŒºåŸŸçš„æ ‡ç­¾ ID

```python
import cv2 as cv
import numpy as np

# 1. è¯»å–å›¾åƒ+äºŒå€¼åŒ–
img = cv.imread('image/IMG_20251221_150348.jpg')
img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
_, img_thr = cv.threshold(img_gray, 96, 255, cv.THRESH_BINARY_INV)

# 2. æ£€æµ‹è¿é€šåŒºåŸŸï¼ˆæ ¸å¿ƒè°ƒç”¨ï¼‰
num_labels, labels = cv.connectedComponents(img_thr, connectivity=8)
print(f"è¿é€šåŒºåŸŸæ€»æ•°ï¼ˆå«èƒŒæ™¯ï¼‰ï¼š{num_labels}")
print(f"æœ‰æ•ˆæ•°å­—åŒºåŸŸæ•°ï¼š{num_labels - 1}")  # å‡å»èƒŒæ™¯æ ‡ç­¾0

# 3. å¯è§†åŒ–è¿é€šåŒºåŸŸï¼ˆç»™ä¸åŒåŒºåŸŸä¸Šè‰²ï¼‰
# åˆ›å»ºå½©è‰²æ ‡ç­¾å›¾ï¼ˆæ–¹ä¾¿åŒºåˆ†ä¸åŒæ•°å­—ï¼‰
label_hue = np.uint8(179 * labels / np.max(labels))  # æ˜ å°„åˆ°HSVè‰²åŸŸ
			# h çš„å€¼å¯å– 0~179
blank_ch = 255 * np.ones_like(label_hue)
label_img = cv.merge([label_hue, blank_ch, blank_ch])
label_img = cv.cvtColor(label_img, cv.COLOR_HSV2BGR)  # è½¬BGR
label_img[label_hue == 0] = 0  # èƒŒæ™¯è®¾ä¸ºé»‘è‰²
			# èŠ±å¼ç´¢å¼•

# 4. éå†æ¯ä¸ªè¿é€šåŒºåŸŸï¼Œè·å–ä½ç½®+ç»˜åˆ¶
for label_id in range(1, num_labels):  # è·³è¿‡èƒŒæ™¯ï¼ˆlabel=0ï¼‰
    # æ‰¾åˆ°å½“å‰æ ‡ç­¾çš„æ‰€æœ‰åƒç´ åæ ‡
    y_coords, x_coords = np.where(labels == label_id)
		    # è¿”å›å€¼æ˜¯yåˆ—è¡¨å’Œxåˆ—è¡¨
    # è®¡ç®—åŒ…å›´æ¡†ï¼ˆæ›¿ä»£boundingRectï¼‰
    x_min, x_max = np.min(x_coords), np.max(x_coords)
    y_min, y_max = np.min(y_coords), np.max(y_coords)
    w, h = x_max - x_min, y_max - y_min
    
    # ç­›é€‰å°åŒºåŸŸï¼ˆæ’é™¤å™ªç‚¹ï¼‰
    area = w * h
    if area < 25:
        continue
    
    # ç»˜åˆ¶åŒ…å›´æ¡†+æ ‡ç­¾ID
    cv.rectangle(img, (x_min, y_min), (x_max, y_max), (0,255,0), 2)
    cv.putText(img, f"ID:{label_id}", (x_min+5, y_min-5), 
               cv.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,255), 1)

# æ˜¾ç¤ºç»“æœ
cv.imshow('åŸå§‹å›¾åƒ+è¿é€šåŒºåŸŸæ¡†', img)
cv.imshow('å½©è‰²è¿é€šåŒºåŸŸæ ‡ç­¾', label_img)
cv.waitKey(0)
cv.destroyAllWindows()
```

`num_labels, labels, stats, centroids = cv.connectedComponentsWithStats(img_thr, connectivity=8)`

- å’Œä¸Šé¢åŒç†ï¼Œå¤šäº†ä¸¤ä¸ªè¿”å›å€¼
- `stats`ï¼šå½¢çŠ¶ä¸ºÂ `(num_labels, 5)`Â çš„çŸ©é˜µï¼Œæ¯ä¸€è¡ŒåŒ…æ‹¬`[x, y, w, h, area]`
- `centroids`ï¼šå½¢çŠ¶ä¸ºÂ `(num_labels, 2)`Â çš„çŸ©é˜µï¼Œæ¯ä¸€è¡Œæ˜¯å¯¹åº”æ ‡ç­¾çš„é‡å¿ƒåæ ‡Â `(cx, cy)`
- ä¸Šè¿°åŒ…æ‹¬èƒŒæ™¯çš„ç»Ÿè®¡ä¿¡æ¯

## ç›®æ ‡è¿½è¸ª

### 1. å¯ä»¥ä½¿ç”¨è¿é€šåŸŸ/æŸ¥æ‰¾è½®å»“

```python
import cv2 as cv
import numpy as np

# ä½¿ç”¨æ»‘åŠ¨æ¡è¿›è¡Œé¢œè‰²è¿½è¸ªï¼Œåœ¨hsvå›¾åƒä¸Šåˆ’åˆ†è‰²å—ï¼Œåœ¨bgrå›¾åƒä¸Šæ¡†é€‰ç›®æ ‡

# åˆ›å»ºçª—å£å’Œæ»‘åŠ¨æ¡
WINDOW_NAME = 'track'
cv.namedWindow('track', cv.WINDOW_NORMAL)
trackerbars = [('H_min', 0, 179),  # æ»‘åŠ¨æ¡åç§° åˆå§‹å€¼ æœ€å¤§å€¼
               ('S_min', 0, 255),
               ('V_min', 0 ,255),
               ('H_max', 60, 179),
               ('S_max', 255, 255),
               ('V_max', 255 ,255)]
for bar in trackerbars:
    cv.createTrackbar(bar[0], WINDOW_NAME, bar[1], bar[2], lambda x: None)

# è¿½è¸ªé¢œè‰²
cap = cv.VideoCapture(0)

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break
    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)

    # è·å– h, s, vçš„æœ€å°å€¼æœ€å¤§å€¼
    vals = []
    for name, _, _ in trackerbars:
        val = cv.getTrackbarPos(name, WINDOW_NAME)
        vals.append(val)
    h_min, s_min, v_min, h_max, s_max, v_max = vals

    # è¯†åˆ«è”é€šåŒº
    mask = cv.inRange(hsv, (h_min, s_min, v_min), (h_max, s_max, v_max))
    num, label, stats, centres = cv.connectedComponentsWithStats(mask)
    
    # åœ¨hsvä¸Šåˆ’åˆ†è‰²å—
    for n in range(num):
        if stats[n, 4] < 50:  # è·³è¿‡é¢ç§¯å°äº50çš„åŒºåŸŸ
            continue
        hsv[label == n] = (int(179*n/num), 255, 255)
    
    # åœ¨bgrä¸Šæ¡†é€‰ç›®æ ‡
    for (x, y, w, h, area) in stats[1:]:  # è·³è¿‡èƒŒæ™¯
        if area < 50 :
            continue
        cv.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)
    
    hsv = cv.cvtColor(hsv, cv.COLOR_HSV2BGR)
    cv.imshow('bgr', frame)
    cv.imshow('hsv', hsv)

    if cv.waitKey(50) == ord('q'):
        break
cap.release()
cv.destroyAllWindows()
```
### 2. å¯ä»¥ä½¿ç”¨è¿½è¸ªå™¨

```python
import cv2 as cv
import numpy as np

# åˆ›å»ºè¿½è¸ªå™¨
def createTracker(trackType='CSRT'):
    trackType = trackType.upper()
    trackTypes = {
        'CSRT': cv.TrackerCSRT_create,
        'KCK': cv.TrackerKCF_create
        }
    if trackType not in trackTypes:
        print("é»˜è®¤ä½¿ç”¨CSRT")
        trackType = 'CSRT'
    return trackTypes[trackType]()    # ä¸ºä»€ä¹ˆè¦åŠ æ‹¬å·

# ä½¿ç”¨è¿½è¸ªå™¨è¿½è¸ªç‰©ä½“
tracker = createTracker()
cap = cv.VideoCapture(0)

#é€‰æ‹©è¿½è¸ªç›®æ ‡
ret, frame = cap.read()
roibox = cv.selectROI('é€‰æ‹©åŒºåŸŸ', frame, fromCenter=False, showCrosshair=True) # åé¢ä¸¤ä¸ªå‚æ•°æœ‰ä»€ä¹ˆç”¨
cv.destroyWindow('é€‰æ‹©åŒºåŸŸ')
tracker.init(frame, roibox)

# è¿½è¸ª
while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        exit(1)
    ret, roibox = tracker.update(frame)

    # è¿½è¸ªæˆåŠŸ
    if ret:
        x, y, w, h = [int(x) for x in roibox]
        cv.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 1)
    cv.imshow('tracking', frame)
    if cv.waitKey(50) == ord('q'):
        break
cap.release()
cv.destroyAllWindows()
```
